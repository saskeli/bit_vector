<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bit vector: bv::bit_vector&lt; leaf, node, allocator, leaf_size, branches, dtype &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bit vector
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Fast and space efficient dynamic bit vector library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bv</b></li><li class="navelem"><a class="el" href="classbv_1_1bit__vector.html">bit_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classbv_1_1bit__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bv::bit_vector&lt; leaf, node, allocator, leaf_size, branches, dtype &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container class for dynamic b-tree bit vector stuctures.  
 <a href="classbv_1_1bit__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="bit__vector_8hpp_source.html">bit_vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for bv::bit_vector&lt; leaf, node, allocator, leaf_size, branches, dtype &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classbv_1_1bit__vector__coll__graph.png" border="0" usemap="#bv_1_1bit__vector_3_01leaf_00_01node_00_01allocator_00_01leaf__size_00_01branches_00_01dtype_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="bv_1_1bit__vector_3_01leaf_00_01node_00_01allocator_00_01leaf__size_00_01branches_00_01dtype_01_4_coll__map" id="bv_1_1bit__vector_3_01leaf_00_01node_00_01allocator_00_01leaf__size_00_01branches_00_01dtype_01_4_coll__map">
<area shape="rect" title="Container class for dynamic b&#45;tree bit vector stuctures." alt="" coords="123,109,306,165"/>
<area shape="rect" href="classbv_1_1node.html" title="Internal node for use with bit vector b&#45;tree structures." alt="" coords="5,5,216,47"/>
<area shape="rect" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b&#45;tree bit vector." alt="" coords="240,5,400,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa31ef41be5f20c1ac67260a14877160"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#afa31ef41be5f20c1ac67260a14877160">bit_vector</a> (allocator *alloc)</td></tr>
<tr class="memdesc:afa31ef41be5f20c1ac67260a14877160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit vector constructor with existing allocator.  <a href="classbv_1_1bit__vector.html#afa31ef41be5f20c1ac67260a14877160">More...</a><br /></td></tr>
<tr class="separator:afa31ef41be5f20c1ac67260a14877160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed34138f9c8bc42e139a4737a978a1cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#aed34138f9c8bc42e139a4737a978a1cd">bit_vector</a> ()</td></tr>
<tr class="memdesc:aed34138f9c8bc42e139a4737a978a1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that creates an owned allocator.  <a href="classbv_1_1bit__vector.html#aed34138f9c8bc42e139a4737a978a1cd">More...</a><br /></td></tr>
<tr class="separator:aed34138f9c8bc42e139a4737a978a1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e6b4e4fb95b2b6b28982669899556"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a626e6b4e4fb95b2b6b28982669899556">~bit_vector</a> ()</td></tr>
<tr class="memdesc:a626e6b4e4fb95b2b6b28982669899556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor that deallocates the entire data structure.  <a href="classbv_1_1bit__vector.html#a626e6b4e4fb95b2b6b28982669899556">More...</a><br /></td></tr>
<tr class="separator:a626e6b4e4fb95b2b6b28982669899556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca847b9c081d8b677f5bd7b7b8b88d3e"><td class="memTemplParams" colspan="2">template&lt;dtype block_size = 2048&gt; </td></tr>
<tr class="memitem:aca847b9c081d8b677f5bd7b7b8b88d3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#aca847b9c081d8b677f5bd7b7b8b88d3e">generate_query_structure</a> (<a class="el" href="classbv_1_1query__support.html">query_support</a>&lt; dtype, <a class="el" href="classbv_1_1leaf.html">leaf</a>, block_size &gt; *qs) const</td></tr>
<tr class="memdesc:aca847b9c081d8b677f5bd7b7b8b88d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a given query support stucture using <code>this</code>  <a href="classbv_1_1bit__vector.html#aca847b9c081d8b677f5bd7b7b8b88d3e">More...</a><br /></td></tr>
<tr class="separator:aca847b9c081d8b677f5bd7b7b8b88d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94dbda4eac1f26f93e8b9c37a058d98"><td class="memTemplParams" colspan="2">template&lt;dtype block_size = leaf_size / 3&gt; </td></tr>
<tr class="memitem:ae94dbda4eac1f26f93e8b9c37a058d98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbv_1_1query__support.html">query_support</a>&lt; dtype, <a class="el" href="classbv_1_1leaf.html">leaf</a>, block_size &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#ae94dbda4eac1f26f93e8b9c37a058d98">generate_query_structure</a> () const</td></tr>
<tr class="memdesc:ae94dbda4eac1f26f93e8b9c37a058d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and Populate a query support structure using <code>this</code>  <a href="classbv_1_1bit__vector.html#ae94dbda4eac1f26f93e8b9c37a058d98">More...</a><br /></td></tr>
<tr class="separator:ae94dbda4eac1f26f93e8b9c37a058d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50359f3006b3385bca19c1f66837989f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a50359f3006b3385bca19c1f66837989f">insert</a> (uint64_t index, bool value)</td></tr>
<tr class="memdesc:a50359f3006b3385bca19c1f66837989f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert "value" into position "index".  <a href="classbv_1_1bit__vector.html#a50359f3006b3385bca19c1f66837989f">More...</a><br /></td></tr>
<tr class="separator:a50359f3006b3385bca19c1f66837989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90c658e7247819d6ce5c6c2e122f847"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#af90c658e7247819d6ce5c6c2e122f847">remove</a> (uint64_t index)</td></tr>
<tr class="memdesc:af90c658e7247819d6ce5c6c2e122f847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove element at "index".  <a href="classbv_1_1bit__vector.html#af90c658e7247819d6ce5c6c2e122f847">More...</a><br /></td></tr>
<tr class="separator:af90c658e7247819d6ce5c6c2e122f847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc35998360ebf979440b900a7f0cb0d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a8bc35998360ebf979440b900a7f0cb0d">sum</a> () const</td></tr>
<tr class="memdesc:a8bc35998360ebf979440b900a7f0cb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of 1-bits in the data structure.  <a href="classbv_1_1bit__vector.html#a8bc35998360ebf979440b900a7f0cb0d">More...</a><br /></td></tr>
<tr class="separator:a8bc35998360ebf979440b900a7f0cb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27db13321587d2d1d6d84c656c5c57e4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a27db13321587d2d1d6d84c656c5c57e4">size</a> () const</td></tr>
<tr class="memdesc:a27db13321587d2d1d6d84c656c5c57e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements stored in the data structure.  <a href="classbv_1_1bit__vector.html#a27db13321587d2d1d6d84c656c5c57e4">More...</a><br /></td></tr>
<tr class="separator:a27db13321587d2d1d6d84c656c5c57e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8e0e257c0c1d71285afd14c24b3714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a7d8e0e257c0c1d71285afd14c24b3714">at</a> (uint64_t index) const</td></tr>
<tr class="memdesc:a7d8e0e257c0c1d71285afd14c24b3714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value of the index<sup>th</sup> element in the data structure.  <a href="classbv_1_1bit__vector.html#a7d8e0e257c0c1d71285afd14c24b3714">More...</a><br /></td></tr>
<tr class="separator:a7d8e0e257c0c1d71285afd14c24b3714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e09275d4a5894bd22bd15fdcf748f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a42e09275d4a5894bd22bd15fdcf748f3">rank</a> (uint64_t index) const</td></tr>
<tr class="memdesc:a42e09275d4a5894bd22bd15fdcf748f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of 1-bits up to position index.  <a href="classbv_1_1bit__vector.html#a42e09275d4a5894bd22bd15fdcf748f3">More...</a><br /></td></tr>
<tr class="separator:a42e09275d4a5894bd22bd15fdcf748f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cce189fc9895ebb1b44f4fe4f9cb2eb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a5cce189fc9895ebb1b44f4fe4f9cb2eb">select</a> (uint64_t count) const</td></tr>
<tr class="memdesc:a5cce189fc9895ebb1b44f4fe4f9cb2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the count<sup>th</sup> 1-bit in the data structure.  <a href="classbv_1_1bit__vector.html#a5cce189fc9895ebb1b44f4fe4f9cb2eb">More...</a><br /></td></tr>
<tr class="separator:a5cce189fc9895ebb1b44f4fe4f9cb2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf657ea587d49412b81044fc245c853f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#adf657ea587d49412b81044fc245c853f">set</a> (uint64_t index, bool value)</td></tr>
<tr class="memdesc:adf657ea587d49412b81044fc245c853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bit at "index" to "value".  <a href="classbv_1_1bit__vector.html#adf657ea587d49412b81044fc245c853f">More...</a><br /></td></tr>
<tr class="separator:adf657ea587d49412b81044fc245c853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c86a5406563b81482628ae018ea8e30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a6c86a5406563b81482628ae018ea8e30">flush</a> ()</td></tr>
<tr class="memdesc:a6c86a5406563b81482628ae018ea8e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively flushes all buffers in the data structure.  <a href="classbv_1_1bit__vector.html#a6c86a5406563b81482628ae018ea8e30">More...</a><br /></td></tr>
<tr class="separator:a6c86a5406563b81482628ae018ea8e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852e5ff9b92c149b3a6698fb53e918f6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a852e5ff9b92c149b3a6698fb53e918f6">bit_size</a> () const</td></tr>
<tr class="memdesc:a852e5ff9b92c149b3a6698fb53e918f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of data structure allocations in bits.  <a href="classbv_1_1bit__vector.html#a852e5ff9b92c149b3a6698fb53e918f6">More...</a><br /></td></tr>
<tr class="separator:a852e5ff9b92c149b3a6698fb53e918f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f68d3946754d40c7257416f2132b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a91f68d3946754d40c7257416f2132b75">validate</a> () const</td></tr>
<tr class="memdesc:a91f68d3946754d40c7257416f2132b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the data structure is internally consistent.  <a href="classbv_1_1bit__vector.html#a91f68d3946754d40c7257416f2132b75">More...</a><br /></td></tr>
<tr class="separator:a91f68d3946754d40c7257416f2132b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d2162a502c79f77869c4bd1aaf2446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#ab4d2162a502c79f77869c4bd1aaf2446">print</a> (bool internal_only) const</td></tr>
<tr class="memdesc:ab4d2162a502c79f77869c4bd1aaf2446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output data structure to standard out as json.  <a href="classbv_1_1bit__vector.html#ab4d2162a502c79f77869c4bd1aaf2446">More...</a><br /></td></tr>
<tr class="separator:ab4d2162a502c79f77869c4bd1aaf2446"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1e991908e2749805c303ee52033c9d14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a1e991908e2749805c303ee52033c9d14">split_root</a> ()</td></tr>
<tr class="memdesc:a1e991908e2749805c303ee52033c9d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the height of the tree by one level.  <a href="classbv_1_1bit__vector.html#a1e991908e2749805c303ee52033c9d14">More...</a><br /></td></tr>
<tr class="separator:a1e991908e2749805c303ee52033c9d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a77524afbfe09f1f45a15a2a7927c49d7"><td class="memItemLeft" align="right" valign="top"><a id="a77524afbfe09f1f45a15a2a7927c49d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a77524afbfe09f1f45a15a2a7927c49d7">root_is_leaf_</a> = true</td></tr>
<tr class="memdesc:a77524afbfe09f1f45a15a2a7927c49d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value indicating whether the root is in <code>n_root_</code> or <code>l_root_</code>. <br /></td></tr>
<tr class="separator:a77524afbfe09f1f45a15a2a7927c49d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18afd5d8170208dd040d7c4845b42b10"><td class="memItemLeft" align="right" valign="top"><a id="a18afd5d8170208dd040d7c4845b42b10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a18afd5d8170208dd040d7c4845b42b10">owned_allocator_</a> = false</td></tr>
<tr class="memdesc:a18afd5d8170208dd040d7c4845b42b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if deallocating the allocator is the responsibilty of the data structure. <br /></td></tr>
<tr class="separator:a18afd5d8170208dd040d7c4845b42b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756dec3c572889c7c9af2a04dfc515db"><td class="memItemLeft" align="right" valign="top"><a id="a756dec3c572889c7c9af2a04dfc515db"></a>
<a class="el" href="classbv_1_1node.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a756dec3c572889c7c9af2a04dfc515db">n_root_</a></td></tr>
<tr class="memdesc:a756dec3c572889c7c9af2a04dfc515db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the b-tree if a multi-level structure is required. <br /></td></tr>
<tr class="separator:a756dec3c572889c7c9af2a04dfc515db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e68bb9811acf634b39ed401b5e9cb69"><td class="memItemLeft" align="right" valign="top"><a id="a9e68bb9811acf634b39ed401b5e9cb69"></a>
<a class="el" href="classbv_1_1leaf.html">leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#a9e68bb9811acf634b39ed401b5e9cb69">l_root_</a></td></tr>
<tr class="memdesc:a9e68bb9811acf634b39ed401b5e9cb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root if a single leaf is sufficient. <br /></td></tr>
<tr class="separator:a9e68bb9811acf634b39ed401b5e9cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a5b14e0bfcaa25ed972d9ee923debc"><td class="memItemLeft" align="right" valign="top"><a id="aa4a5b14e0bfcaa25ed972d9ee923debc"></a>
allocator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1bit__vector.html#aa4a5b14e0bfcaa25ed972d9ee923debc">allocator_</a></td></tr>
<tr class="memdesc:aa4a5b14e0bfcaa25ed972d9ee923debc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to allocator used for allocating internal nodes and leaves. <br /></td></tr>
<tr class="separator:aa4a5b14e0bfcaa25ed972d9ee923debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class leaf, class node, class allocator, uint64_t leaf_size, uint8_t branches, class dtype&gt;<br />
class bv::bit_vector&lt; leaf, node, allocator, leaf_size, branches, dtype &gt;</h3>

<p>Container class for dynamic b-tree bit vector stuctures. </p>
<p>This class manages a dynamic bit vector structure and provides the public API for querying the structure.</p>
<p>The structure supports efficient insertion and removal, along with common bit vector operations (<code>set</code>, access (<code>at</code>), <code>rank</code> and <code>select</code>). Additionally the convenience and debug functions <code>sum</code>, <code>size</code>, <code>bit_size</code>, <code>validate</code>, <code>print</code> and <code>bit_size</code> are provided at no extra cost.</p>
<p>Practical performance depends on node and leaf implementations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">leaf</td><td>Type for leaves. Some kind of <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a>. </td></tr>
    <tr><td class="paramname">node</td><td>Type for internal nodes. Some kind of <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a>. </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator type. For example <a class="el" href="classbv_1_1malloc__alloc.html" title="Simple malloc based allocation for internal nodes and leaves.">bv::malloc_alloc</a>. </td></tr>
    <tr><td class="paramname">leaf_size</td><td>Maximum number of elements in leaf. </td></tr>
    <tr><td class="paramname">branches</td><td>Maximum branching factor of internal node. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa31ef41be5f20c1ac67260a14877160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa31ef41be5f20c1ac67260a14877160">&#9670;&nbsp;</a></span>bit_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::<a class="el" href="classbv_1_1bit__vector.html">bit_vector</a> </td>
          <td>(</td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit vector constructor with existing allocator. </p>
<p>One allocator can be used to provide services for multiple bit vector instances. There is no practical benefit from sharing <a class="el" href="classbv_1_1malloc__alloc.html" title="Simple malloc based allocation for internal nodes and leaves.">bv::malloc_alloc</a> allocators, but a performance benefit is expected by sharing more advanced allocators between multiple bit vector instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed34138f9c8bc42e139a4737a978a1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed34138f9c8bc42e139a4737a978a1cd">&#9670;&nbsp;</a></span>bit_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::<a class="el" href="classbv_1_1bit__vector.html">bit_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that creates an owned allocator. </p>
<p>The default constructor will create an owned allocator that gets deallocated along with the rest of the data structure. </p>

</div>
</div>
<a id="a626e6b4e4fb95b2b6b28982669899556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e6b4e4fb95b2b6b28982669899556">&#9670;&nbsp;</a></span>~bit_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::~<a class="el" href="classbv_1_1bit__vector.html">bit_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deconstructor that deallocates the entire data structure. </p>
<p>All of the internal nodes and leaves allocated for this datastucture get recursively deallocated before deallocation of the bit vector container. If the allocator is owned by the bit vector container, that will be dallocated as well. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7d8e0e257c0c1d71285afd14c24b3714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8e0e257c0c1d71285afd14c24b3714">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::at </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value of the index<sup>th</sup> element in the data structure. </p>
<p>Performs an at-query on either <code>n_root_</code> or <code>l_root_</code> based on tree status.</p>
<p>When using <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> element for the internal data structure, access operations take \(\mathcal{O}\left(\log_2(b)\log_b(n / l)\right)\) time, where \(b\) is the branching factor, \(l\) is the leaf size and \(n\) is the data structure size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating if the index<sup>th</sup> element is set. </dd></dl>

</div>
</div>
<a id="a852e5ff9b92c149b3a6698fb53e918f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852e5ff9b92c149b3a6698fb53e918f6">&#9670;&nbsp;</a></span>bit_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::bit_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total size of data structure allocations in bits. </p>
<p>Calculates the total size of "this", allocated nodes and allocated leaves in bits.</p>
<p>Size of the allocator is not included, and no consideration is made on the effects of memory fragmentation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>8 * sizeof(bit_vector) + tree_size</code> </dd></dl>

</div>
</div>
<a id="a6c86a5406563b81482628ae018ea8e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c86a5406563b81482628ae018ea8e30">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively flushes all buffers in the data structure. </p>
<p>If execution transitions to a phase where no insertions or removals are expected, flushing all buffers should improve query time at the cost of a fairly expensive flushing operations. </p>

</div>
</div>
<a id="ae94dbda4eac1f26f93e8b9c37a058d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94dbda4eac1f26f93e8b9c37a058d98">&#9670;&nbsp;</a></span>generate_query_structure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<div class="memtemplate">
template&lt;dtype block_size = leaf_size / 3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1query__support.html">query_support</a>&lt;dtype, <a class="el" href="classbv_1_1leaf.html">leaf</a>, block_size&gt;* <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::generate_query_structure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and Populate a query support structure using <code>this</code> </p>
<p>Creates a new support structure and adds leaves in order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">block_size</td><td>Size of blocks used in the query support structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new query support strucutre. </dd></dl>

</div>
</div>
<a id="aca847b9c081d8b677f5bd7b7b8b88d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca847b9c081d8b677f5bd7b7b8b88d3e">&#9670;&nbsp;</a></span>generate_query_structure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<div class="memtemplate">
template&lt;dtype block_size = 2048&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::generate_query_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1query__support.html">query_support</a>&lt; dtype, <a class="el" href="classbv_1_1leaf.html">leaf</a>, block_size &gt; *&#160;</td>
          <td class="paramname"><em>qs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a given query support stucture using <code>this</code> </p>
<p>Traverses the tree and ads encountered leaves to the query support strucutre.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">block_size</td><td>Size of blocks used in the query support structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qs</td><td>Query support structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50359f3006b3385bca19c1f66837989f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50359f3006b3385bca19c1f66837989f">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert "value" into position "index". </p>
<p>The bit vector container ensures that there is sufficient space in the b-tree, splitting nodes and increasing the tree height as necessary.</p>
<p>Insert operations take \(\mathcal{O}\left(b\log_b(n / l) + l\right)\) amortized time when using <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> elements for data storage, where \(b\) is the branching factor, \(l\) is the leaf size and \(n\) is the data structure size. The branching overhead compared to the access operation is due to updating cumulative sums and sizes in the internal nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Where should <code>value</code> be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>What should be inserted at <code>index</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4d2162a502c79f77869c4bd1aaf2446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d2162a502c79f77869c4bd1aaf2446">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internal_only</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output data structure to standard out as json. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal_only</td><td>If true, actual bit vector data will not be output to save space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42e09275d4a5894bd22bd15fdcf748f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e09275d4a5894bd22bd15fdcf748f3">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::rank </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of 1-bits up to position index. </p>
<p>Counts the number of bits set in the first index bits.</p>
<p>When using <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> elements for the internal data structure, rank operations take \(\mathcal{O}\left(\log_2(b)\log_b(n / l) + l\right)\) time, where \(b\) is the branching factor, \(l\) is the leaf size and \(n\) is the data structure size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Number of elements to include in the "summation".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\sum_{i = 0}^{\mathrm{index - 1}} \mathrm{bv}[i]\). </dd></dl>

</div>
</div>
<a id="af90c658e7247819d6ce5c6c2e122f847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90c658e7247819d6ce5c6c2e122f847">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove element at "index". </p>
<p>Removes a bit from the underlying data structure, decreasing the tree height as appropriate. Tree height is decreased if <code>n_roor_</code> is the active root and has exactly one child.</p>
<p>Remove operations take \(\mathcal{O}\left(b\log_b(n / l) + l\right)\) amortized time when using <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> elements for data storage, where \(b\) is the branching factor, \(l\) is the leaf size and \(n\) is the data structure size. The branching overhead compared to the access operation is due to updating cumulative sums and sizes in the internal nodes.</p>
<p>The value of the removed bit needs to be bubbled up the data structure to update cumulative sums. This makes returning the removed value here a 0-cost "side effect".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Position of element to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the removed bit. </dd></dl>

</div>
</div>
<a id="a5cce189fc9895ebb1b44f4fe4f9cb2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cce189fc9895ebb1b44f4fe4f9cb2eb">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::select </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the count<sup>th</sup> 1-bit in the data structure. </p>
<p>When using <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> for internal strucutres, finds the position of the count<sup>th</sup> 1-bit is found in \(\mathcal{O}\left(\log_2(b)\log_b(n / l) + l\right) \) time, where \(b\) is the branching factor, \(l\) is the leaf size and \(n\) is the data structure size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Selection target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\underset{i \in [0..n)}{\mathrm{arg min}}\left(\sum_{j = 0}^i \mathrm{bv}[j]\right) = \) count. </dd></dl>

</div>
</div>
<a id="adf657ea587d49412b81044fc245c853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf657ea587d49412b81044fc245c853f">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::set </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bit at "index" to "value". </p>
<p>When using <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> for internal strucutres, sets the value of the index<sup>th</sup> bit in \(\mathcal{O}\left(b\log_b(n / l)\right) \) time, where \(b\) is the branching factor, \(l\) is the leaf size and \(n\) is the data structure size. As with insertion and removal there is overhead in updating internal nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to set. </td></tr>
    <tr><td class="paramname">value</td><td>value to set the index<sup>th</sup> bit to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27db13321587d2d1d6d84c656c5c57e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27db13321587d2d1d6d84c656c5c57e4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements stored in the data structure. </p>
<p>Cumulative sizes are maintained as the data structure changes. As such this is a constant time lookup operation.</p>
<dl class="section return"><dt>Returns</dt><dd>\(n\). </dd></dl>

</div>
</div>
<a id="a1e991908e2749805c303ee52033c9d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e991908e2749805c303ee52033c9d14">&#9670;&nbsp;</a></span>split_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::split_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the height of the tree by one level. </p>
<p>A full root node will be split into two and nodes are set as children of a new root node.</p>
<p>The root node will be kept as the only node with less than <code>branches/2</code> children. The child nodes will each have exactly <code>branches/2</code> children. </p>

</div>
</div>
<a id="a8bc35998360ebf979440b900a7f0cb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc35998360ebf979440b900a7f0cb0d">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of 1-bits in the data structure. </p>
<p>Cumulative partial sums are maintained as the data structure changes. As such this is a constant time lookup operation.</p>
<dl class="section return"><dt>Returns</dt><dd>\(\sum_{i = 0}^{n - 1} \mathrm{bv}[i]\) for \(n\) element bit vector. </dd></dl>

</div>
</div>
<a id="a91f68d3946754d40c7257416f2132b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f68d3946754d40c7257416f2132b75">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf , class node , class allocator , uint64_t leaf_size, uint8_t branches, class dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1bit__vector.html">bv::bit_vector</a>&lt; <a class="el" href="classbv_1_1leaf.html">leaf</a>, <a class="el" href="classbv_1_1node.html">node</a>, allocator, leaf_size, branches, dtype &gt;::validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asserts that the data structure is internally consistent. </p>
<p>Walks through the entire data structure and ensures that invariants and cumulative sums and sizes are valid for a data structure of the specified type.</p>
<p>This does not guarantee that the data structure is correct given the preceding query sequence, simply checks that a valid data structure seems to be correctly defined.</p>
<p>If the <code>-DNDEBUG</code> compiler flag is given, this function will do nothing since assertions will be <code>(void(0))</code>ed out. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bit_vector/internal/<a class="el" href="bit__vector_8hpp_source.html">bit_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 26 2021 14:20:52 for Bit vector by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
