<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bit vector: bv::node&lt; leaf_type, dtype, leaf_size, branches &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bit vector
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Fast and space efficient dynamic bit vector library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bv</b></li><li class="navelem"><a class="el" href="classbv_1_1node.html">node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classbv_1_1node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bv::node&lt; leaf_type, dtype, leaf_size, branches &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal node for use with bit vector b-tree structures.  
 <a href="classbv_1_1node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8hpp_source.html">node.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d51a19bc649c8292a03211b1cdcfde9"><td class="memItemLeft" align="right" valign="top"><a id="a3d51a19bc649c8292a03211b1cdcfde9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a3d51a19bc649c8292a03211b1cdcfde9">node</a> ()</td></tr>
<tr class="memdesc:a3d51a19bc649c8292a03211b1cdcfde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a3d51a19bc649c8292a03211b1cdcfde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44659dc05b545f8058845702d4139dbc"><td class="memTemplParams" colspan="2"><a id="a44659dc05b545f8058845702d4139dbc"></a>
template&lt;class qds &gt; </td></tr>
<tr class="memitem:a44659dc05b545f8058845702d4139dbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generate_query_structure</b> (qds *qs)</td></tr>
<tr class="separator:a44659dc05b545f8058845702d4139dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25112ec2200c74cb83b6feab93ef9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ab25112ec2200c74cb83b6feab93ef9a1">has_leaves</a> (bool leaves)</td></tr>
<tr class="memdesc:ab25112ec2200c74cb83b6feab93ef9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the children of the node are leaves or internal nodes.  <a href="classbv_1_1node.html#ab25112ec2200c74cb83b6feab93ef9a1">More...</a><br /></td></tr>
<tr class="separator:ab25112ec2200c74cb83b6feab93ef9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8ab5b2b761ac226f455dfad665162e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a6d8ab5b2b761ac226f455dfad665162e">has_leaves</a> () const</td></tr>
<tr class="memdesc:a6d8ab5b2b761ac226f455dfad665162e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of children for the node.  <a href="classbv_1_1node.html#a6d8ab5b2b761ac226f455dfad665162e">More...</a><br /></td></tr>
<tr class="separator:a6d8ab5b2b761ac226f455dfad665162e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac704bf7b4d5ddfc2f150f9d73ee68bea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ac704bf7b4d5ddfc2f150f9d73ee68bea">at</a> (dtype index) const</td></tr>
<tr class="memdesc:ac704bf7b4d5ddfc2f150f9d73ee68bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value of the index<sup>th</sup> element of the logical structure.  <a href="classbv_1_1node.html#ac704bf7b4d5ddfc2f150f9d73ee68bea">More...</a><br /></td></tr>
<tr class="separator:ac704bf7b4d5ddfc2f150f9d73ee68bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf12280dae2634721d0d8d8206fee63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a2bf12280dae2634721d0d8d8206fee63">set</a> (dtype index, bool v)</td></tr>
<tr class="memdesc:a2bf12280dae2634721d0d8d8206fee63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the logical index<sup>th</sup> element to v.  <a href="classbv_1_1node.html#a2bf12280dae2634721d0d8d8206fee63">More...</a><br /></td></tr>
<tr class="separator:a2bf12280dae2634721d0d8d8206fee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9c306d0befba0e1fca4d6178aaf6f0"><td class="memItemLeft" align="right" valign="top">dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#afe9c306d0befba0e1fca4d6178aaf6f0">rank</a> (dtype index) const</td></tr>
<tr class="memdesc:afe9c306d0befba0e1fca4d6178aaf6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of one bits up to the index<sup>th</sup> logical element.  <a href="classbv_1_1node.html#afe9c306d0befba0e1fca4d6178aaf6f0">More...</a><br /></td></tr>
<tr class="separator:afe9c306d0befba0e1fca4d6178aaf6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48b17e82e1a4a81aa80d6fd38991383"><td class="memItemLeft" align="right" valign="top">dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ab48b17e82e1a4a81aa80d6fd38991383">select</a> (dtype count) const</td></tr>
<tr class="memdesc:ab48b17e82e1a4a81aa80d6fd38991383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the index of the count<sup>tu</sup> 1-bit.  <a href="classbv_1_1node.html#ab48b17e82e1a4a81aa80d6fd38991383">More...</a><br /></td></tr>
<tr class="separator:ab48b17e82e1a4a81aa80d6fd38991383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae139057da6d7a5e248b321f3914468e6"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:ae139057da6d7a5e248b321f3914468e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ae139057da6d7a5e248b321f3914468e6">deallocate</a> (allocator *alloc)</td></tr>
<tr class="memdesc:ae139057da6d7a5e248b321f3914468e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively deallocates all children.  <a href="classbv_1_1node.html#ae139057da6d7a5e248b321f3914468e6">More...</a><br /></td></tr>
<tr class="separator:ae139057da6d7a5e248b321f3914468e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847a9047faf8dfbd52b3a2b91197cf0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ac847a9047faf8dfbd52b3a2b91197cf0">child_count</a> () const</td></tr>
<tr class="memdesc:ac847a9047faf8dfbd52b3a2b91197cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of children of this node.  <a href="classbv_1_1node.html#ac847a9047faf8dfbd52b3a2b91197cf0">More...</a><br /></td></tr>
<tr class="separator:ac847a9047faf8dfbd52b3a2b91197cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9966c28ef766b094cc83b2c8fb463f"><td class="memItemLeft" align="right" valign="top">void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#aca9966c28ef766b094cc83b2c8fb463f">children</a> ()</td></tr>
<tr class="memdesc:aca9966c28ef766b094cc83b2c8fb463f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the children of this node.  <a href="classbv_1_1node.html#aca9966c28ef766b094cc83b2c8fb463f">More...</a><br /></td></tr>
<tr class="separator:aca9966c28ef766b094cc83b2c8fb463f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7107ee49f44c1fc4af123ac20855434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbv_1_1branchless__scan.html">branching</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#aa7107ee49f44c1fc4af123ac20855434">child_sizes</a> ()</td></tr>
<tr class="memdesc:aa7107ee49f44c1fc4af123ac20855434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the cumulative child sizes.  <a href="classbv_1_1node.html#aa7107ee49f44c1fc4af123ac20855434">More...</a><br /></td></tr>
<tr class="separator:aa7107ee49f44c1fc4af123ac20855434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01debf052fe9f5831aa56c40de9cbe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbv_1_1branchless__scan.html">branching</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#af01debf052fe9f5831aa56c40de9cbe4">child_sums</a> ()</td></tr>
<tr class="memdesc:af01debf052fe9f5831aa56c40de9cbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the cumulative child sums.  <a href="classbv_1_1node.html#af01debf052fe9f5831aa56c40de9cbe4">More...</a><br /></td></tr>
<tr class="separator:af01debf052fe9f5831aa56c40de9cbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdfb951964fa5b8583178a79671e392"><td class="memItemLeft" align="right" valign="top">dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#acbdfb951964fa5b8583178a79671e392">size</a> () const</td></tr>
<tr class="memdesc:acbdfb951964fa5b8583178a79671e392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical number of elements stored in the subtree.  <a href="classbv_1_1node.html#acbdfb951964fa5b8583178a79671e392">More...</a><br /></td></tr>
<tr class="separator:acbdfb951964fa5b8583178a79671e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf18e7fb6cd2f123b4ac9726dacdbee"><td class="memItemLeft" align="right" valign="top">dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a3bf18e7fb6cd2f123b4ac9726dacdbee">p_sum</a> () const</td></tr>
<tr class="memdesc:a3bf18e7fb6cd2f123b4ac9726dacdbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical number of 1-bits stored in the subtree.  <a href="classbv_1_1node.html#a3bf18e7fb6cd2f123b4ac9726dacdbee">More...</a><br /></td></tr>
<tr class="separator:a3bf18e7fb6cd2f123b4ac9726dacdbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667820844114f3bb0004272dcc8c077b"><td class="memTemplParams" colspan="2">template&lt;class child &gt; </td></tr>
<tr class="memitem:a667820844114f3bb0004272dcc8c077b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a667820844114f3bb0004272dcc8c077b">append_child</a> (<a class="el" href="classbv_1_1node.html#a95404ba2d241e1621c305ec511026fce">child</a> *new_child)</td></tr>
<tr class="memdesc:a667820844114f3bb0004272dcc8c077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add child to the subtree.  <a href="classbv_1_1node.html#a667820844114f3bb0004272dcc8c077b">More...</a><br /></td></tr>
<tr class="separator:a667820844114f3bb0004272dcc8c077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95404ba2d241e1621c305ec511026fce"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a95404ba2d241e1621c305ec511026fce">child</a> (uint8_t i)</td></tr>
<tr class="memdesc:a95404ba2d241e1621c305ec511026fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get i<sup>th</sup> child of the node.  <a href="classbv_1_1node.html#a95404ba2d241e1621c305ec511026fce">More...</a><br /></td></tr>
<tr class="separator:a95404ba2d241e1621c305ec511026fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf15e749a6311c34ae62eaa4ad9ddfd9"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:acf15e749a6311c34ae62eaa4ad9ddfd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#acf15e749a6311c34ae62eaa4ad9ddfd9">insert</a> (dtype index, bool value, allocator *alloc)</td></tr>
<tr class="memdesc:acf15e749a6311c34ae62eaa4ad9ddfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert "value" at "index".  <a href="classbv_1_1node.html#acf15e749a6311c34ae62eaa4ad9ddfd9">More...</a><br /></td></tr>
<tr class="separator:acf15e749a6311c34ae62eaa4ad9ddfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1ee834ac68d417cfcdfd18b098b98b"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:ada1ee834ac68d417cfcdfd18b098b98b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ada1ee834ac68d417cfcdfd18b098b98b">remove</a> (dtype index, allocator *alloc)</td></tr>
<tr class="memdesc:ada1ee834ac68d417cfcdfd18b098b98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the index<sup>th</sup> element.  <a href="classbv_1_1node.html#ada1ee834ac68d417cfcdfd18b098b98b">More...</a><br /></td></tr>
<tr class="separator:ada1ee834ac68d417cfcdfd18b098b98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1213cc63e7b62e7923ae94fca02787c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#aa1213cc63e7b62e7923ae94fca02787c">clear_first</a> (uint8_t elems)</td></tr>
<tr class="memdesc:aa1213cc63e7b62e7923ae94fca02787c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the first "elems" elements form this node.  <a href="classbv_1_1node.html#aa1213cc63e7b62e7923ae94fca02787c">More...</a><br /></td></tr>
<tr class="separator:aa1213cc63e7b62e7923ae94fca02787c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e149d613997ccfeb052ad7d181f7fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a5e149d613997ccfeb052ad7d181f7fcc">transfer_append</a> (<a class="el" href="classbv_1_1node.html">node</a> *other, uint8_t elems)</td></tr>
<tr class="memdesc:a5e149d613997ccfeb052ad7d181f7fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the fist "elems" elements from "other" to the end of "this".  <a href="classbv_1_1node.html#a5e149d613997ccfeb052ad7d181f7fcc">More...</a><br /></td></tr>
<tr class="separator:a5e149d613997ccfeb052ad7d181f7fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0a2977c1024b410e84b9e4be7397d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#adf0a2977c1024b410e84b9e4be7397d6">clear_last</a> (uint8_t elems)</td></tr>
<tr class="memdesc:adf0a2977c1024b410e84b9e4be7397d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last "elems" elemets from the node.  <a href="classbv_1_1node.html#adf0a2977c1024b410e84b9e4be7397d6">More...</a><br /></td></tr>
<tr class="separator:adf0a2977c1024b410e84b9e4be7397d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5c13dba4cac468ffc2513f55335dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#afd5c13dba4cac468ffc2513f55335dae">transfer_prepend</a> (<a class="el" href="classbv_1_1node.html">node</a> *other, uint8_t elems)</td></tr>
<tr class="memdesc:afd5c13dba4cac468ffc2513f55335dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the last "elems" elements from "other" to the start of "this".  <a href="classbv_1_1node.html#afd5c13dba4cac468ffc2513f55335dae">More...</a><br /></td></tr>
<tr class="separator:afd5c13dba4cac468ffc2513f55335dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064a3b2686b8e4f4264d0fdcb510aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a3064a3b2686b8e4f4264d0fdcb510aed">append_all</a> (<a class="el" href="classbv_1_1node.html">node</a> *other)</td></tr>
<tr class="memdesc:a3064a3b2686b8e4f4264d0fdcb510aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all children from "other" to the end of this node.  <a href="classbv_1_1node.html#a3064a3b2686b8e4f4264d0fdcb510aed">More...</a><br /></td></tr>
<tr class="separator:a3064a3b2686b8e4f4264d0fdcb510aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8058dc416614319ee5c00c473dc8146"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ac8058dc416614319ee5c00c473dc8146">bits_size</a> () const</td></tr>
<tr class="memdesc:ac8058dc416614319ee5c00c473dc8146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the subtree in "allocated" bits.  <a href="classbv_1_1node.html#ac8058dc416614319ee5c00c473dc8146">More...</a><br /></td></tr>
<tr class="separator:ac8058dc416614319ee5c00c473dc8146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad247f94aafd46dead4a8b1d55a1b2393"><td class="memItemLeft" align="right" valign="top"><a id="ad247f94aafd46dead4a8b1d55a1b2393"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="separator:ad247f94aafd46dead4a8b1d55a1b2393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f9dc1092d0dbac400e2eaa0787ae17"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#af6f9dc1092d0dbac400e2eaa0787ae17">validate</a> () const</td></tr>
<tr class="memdesc:af6f9dc1092d0dbac400e2eaa0787ae17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the subtree structure is internally consistent.  <a href="classbv_1_1node.html#af6f9dc1092d0dbac400e2eaa0787ae17">More...</a><br /></td></tr>
<tr class="separator:af6f9dc1092d0dbac400e2eaa0787ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102f163e9ac6b0842c11ce624aa19642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a102f163e9ac6b0842c11ce624aa19642">print</a> (bool internal_only) const</td></tr>
<tr class="memdesc:a102f163e9ac6b0842c11ce624aa19642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this subtree as json.  <a href="classbv_1_1node.html#a102f163e9ac6b0842c11ce624aa19642">More...</a><br /></td></tr>
<tr class="separator:a102f163e9ac6b0842c11ce624aa19642"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a930b2c57240dca3c4c8c5c6f2ca7b35b"><td class="memItemLeft" align="right" valign="top"><a id="a930b2c57240dca3c4c8c5c6f2ca7b35b"></a>
typedef <a class="el" href="classbv_1_1branchless__scan.html">branchless_scan</a>&lt; dtype, branches &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>branching</b></td></tr>
<tr class="separator:a930b2c57240dca3c4c8c5c6f2ca7b35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abfa478cf40b029e8e89c99ad4fd62b19"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:abfa478cf40b029e8e89c99ad4fd62b19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#abfa478cf40b029e8e89c99ad4fd62b19">rebalance_leaf</a> (uint8_t index, leaf_type *<a class="el" href="classbv_1_1leaf.html">leaf</a>, allocator *alloc)</td></tr>
<tr class="memdesc:abfa478cf40b029e8e89c99ad4fd62b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that there is space for insertion in the child leaves.  <a href="classbv_1_1node.html#abfa478cf40b029e8e89c99ad4fd62b19">More...</a><br /></td></tr>
<tr class="separator:abfa478cf40b029e8e89c99ad4fd62b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56b0771306c929622f11ecb2903df1d"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:ad56b0771306c929622f11ecb2903df1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ad56b0771306c929622f11ecb2903df1d">leaf_insert</a> (dtype index, bool value, allocator *alloc)</td></tr>
<tr class="memdesc:ad56b0771306c929622f11ecb2903df1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operation if the children are leaves.  <a href="classbv_1_1node.html#ad56b0771306c929622f11ecb2903df1d">More...</a><br /></td></tr>
<tr class="separator:ad56b0771306c929622f11ecb2903df1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7404ff49559a0e9d194d8fd74e1b58ab"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a7404ff49559a0e9d194d8fd74e1b58ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a7404ff49559a0e9d194d8fd74e1b58ab">rebalance_node</a> (uint8_t index, allocator *alloc)</td></tr>
<tr class="memdesc:a7404ff49559a0e9d194d8fd74e1b58ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that there is space for insertion in the child nodes.  <a href="classbv_1_1node.html#a7404ff49559a0e9d194d8fd74e1b58ab">More...</a><br /></td></tr>
<tr class="separator:a7404ff49559a0e9d194d8fd74e1b58ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6918444b124f2f4fd2c9eef9a43117bb"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a6918444b124f2f4fd2c9eef9a43117bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a6918444b124f2f4fd2c9eef9a43117bb">node_insert</a> (dtype index, bool value, allocator *alloc)</td></tr>
<tr class="memdesc:a6918444b124f2f4fd2c9eef9a43117bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operation if the children are internal nodes.  <a href="classbv_1_1node.html#a6918444b124f2f4fd2c9eef9a43117bb">More...</a><br /></td></tr>
<tr class="separator:a6918444b124f2f4fd2c9eef9a43117bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba13b4bd1acc8adf5c69e17cd3e0844"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:afba13b4bd1acc8adf5c69e17cd3e0844"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#afba13b4bd1acc8adf5c69e17cd3e0844">rebalance_leaves_right</a> (leaf_type *a, leaf_type *b, allocator *alloc)</td></tr>
<tr class="memdesc:afba13b4bd1acc8adf5c69e17cd3e0844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from the "right" leaf to the "left" leaf.  <a href="classbv_1_1node.html#afba13b4bd1acc8adf5c69e17cd3e0844">More...</a><br /></td></tr>
<tr class="separator:afba13b4bd1acc8adf5c69e17cd3e0844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2179a509cec5f2cca091d6035472fdf5"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a2179a509cec5f2cca091d6035472fdf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a2179a509cec5f2cca091d6035472fdf5">rebalance_leaves_left</a> (leaf_type *a, leaf_type *b, uint8_t idx, allocator *alloc)</td></tr>
<tr class="memdesc:a2179a509cec5f2cca091d6035472fdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from the "left" leaf to the "right" leaf.  <a href="classbv_1_1node.html#a2179a509cec5f2cca091d6035472fdf5">More...</a><br /></td></tr>
<tr class="separator:a2179a509cec5f2cca091d6035472fdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458944e99726b8562eccbe8f668b9414"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a458944e99726b8562eccbe8f668b9414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a458944e99726b8562eccbe8f668b9414">merge_leaves</a> (leaf_type *a, leaf_type *b, uint8_t idx, allocator *alloc)</td></tr>
<tr class="memdesc:a458944e99726b8562eccbe8f668b9414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the right leaf into the left leaf.  <a href="classbv_1_1node.html#a458944e99726b8562eccbe8f668b9414">More...</a><br /></td></tr>
<tr class="separator:a458944e99726b8562eccbe8f668b9414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679beca7562433e0505191474c63d518"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a679beca7562433e0505191474c63d518"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a679beca7562433e0505191474c63d518">leaf_remove</a> (dtype index, allocator *alloc)</td></tr>
<tr class="memdesc:a679beca7562433e0505191474c63d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal used when the children are leaves.  <a href="classbv_1_1node.html#a679beca7562433e0505191474c63d518">More...</a><br /></td></tr>
<tr class="separator:a679beca7562433e0505191474c63d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bb4e623e06394829bb794586176191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ad3bb4e623e06394829bb794586176191">rebalance_nodes_right</a> (<a class="el" href="classbv_1_1node.html">node</a> *a, <a class="el" href="classbv_1_1node.html">node</a> *b, uint8_t idx)</td></tr>
<tr class="memdesc:ad3bb4e623e06394829bb794586176191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from the "right" node to the "left" node.  <a href="classbv_1_1node.html#ad3bb4e623e06394829bb794586176191">More...</a><br /></td></tr>
<tr class="separator:ad3bb4e623e06394829bb794586176191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df575c9efb74baa579888b780327472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a3df575c9efb74baa579888b780327472">rebalance_nodes_left</a> (<a class="el" href="classbv_1_1node.html">node</a> *a, <a class="el" href="classbv_1_1node.html">node</a> *b, uint8_t idx)</td></tr>
<tr class="memdesc:a3df575c9efb74baa579888b780327472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from the "lef" node to the "right" node.  <a href="classbv_1_1node.html#a3df575c9efb74baa579888b780327472">More...</a><br /></td></tr>
<tr class="separator:a3df575c9efb74baa579888b780327472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848207658f45cb304b07b3478f7fefe5"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a848207658f45cb304b07b3478f7fefe5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a848207658f45cb304b07b3478f7fefe5">merge_nodes</a> (<a class="el" href="classbv_1_1node.html">node</a> *a, <a class="el" href="classbv_1_1node.html">node</a> *b, uint8_t idx, allocator *alloc)</td></tr>
<tr class="memdesc:a848207658f45cb304b07b3478f7fefe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all from the "right" node to the "left" node.  <a href="classbv_1_1node.html#a848207658f45cb304b07b3478f7fefe5">More...</a><br /></td></tr>
<tr class="separator:a848207658f45cb304b07b3478f7fefe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df5aca9c6ae88fff2a762f10964259f"><td class="memTemplParams" colspan="2">template&lt;class allocator &gt; </td></tr>
<tr class="memitem:a1df5aca9c6ae88fff2a762f10964259f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a1df5aca9c6ae88fff2a762f10964259f">node_remove</a> (dtype index, allocator *alloc)</td></tr>
<tr class="memdesc:a1df5aca9c6ae88fff2a762f10964259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal operation when children are internal nodes.  <a href="classbv_1_1node.html#a1df5aca9c6ae88fff2a762f10964259f">More...</a><br /></td></tr>
<tr class="separator:a1df5aca9c6ae88fff2a762f10964259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae01de1c67b5f3e86ef2248f6d4d0a229"><td class="memItemLeft" align="right" valign="top"><a id="ae01de1c67b5f3e86ef2248f6d4d0a229"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#ae01de1c67b5f3e86ef2248f6d4d0a229">meta_data_</a></td></tr>
<tr class="memdesc:ae01de1c67b5f3e86ef2248f6d4d0a229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit indicating whether the nodes children are laves or nodes. <br /></td></tr>
<tr class="separator:ae01de1c67b5f3e86ef2248f6d4d0a229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9c1b74d0f6a33b557ea515c410d01f"><td class="memItemLeft" align="right" valign="top"><a id="a1b9c1b74d0f6a33b557ea515c410d01f"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#a1b9c1b74d0f6a33b557ea515c410d01f">child_count_</a></td></tr>
<tr class="memdesc:a1b9c1b74d0f6a33b557ea515c410d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of active children. <br /></td></tr>
<tr class="separator:a1b9c1b74d0f6a33b557ea515c410d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add484bd7148fa03c910ea1f3c08b16c5"><td class="memItemLeft" align="right" valign="top"><a id="add484bd7148fa03c910ea1f3c08b16c5"></a>
<a class="el" href="classbv_1_1branchless__scan.html">branching</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#add484bd7148fa03c910ea1f3c08b16c5">child_sizes_</a></td></tr>
<tr class="memdesc:add484bd7148fa03c910ea1f3c08b16c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative child sizes and <code>(~0) &gt;&gt; 1</code> for non-existing children. <br /></td></tr>
<tr class="separator:add484bd7148fa03c910ea1f3c08b16c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf31d9477a7748f59ff0e2a1a84e38f"><td class="memItemLeft" align="right" valign="top"><a id="aacf31d9477a7748f59ff0e2a1a84e38f"></a>
<a class="el" href="classbv_1_1branchless__scan.html">branching</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#aacf31d9477a7748f59ff0e2a1a84e38f">child_sums_</a></td></tr>
<tr class="memdesc:aacf31d9477a7748f59ff0e2a1a84e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative child sums and <code>(~0) &gt;&gt; 1</code> for non-existint children. <br /></td></tr>
<tr class="separator:aacf31d9477a7748f59ff0e2a1a84e38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f7465fdf42b31fcab3919ddbbe05b2"><td class="memItemLeft" align="right" valign="top"><a id="af6f7465fdf42b31fcab3919ddbbe05b2"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1node.html#af6f7465fdf42b31fcab3919ddbbe05b2">children_</a> [branches]</td></tr>
<tr class="memdesc:af6f7465fdf42b31fcab3919ddbbe05b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointers to leaf_type or node children. <br /></td></tr>
<tr class="separator:af6f7465fdf42b31fcab3919ddbbe05b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class leaf_type, class dtype, uint64_t leaf_size, uint8_t branches&gt;<br />
class bv::node&lt; leaf_type, dtype, leaf_size, branches &gt;</h3>

<p>Internal node for use with bit vector b-tree structures. </p>
<p>Intended for use with <a class="el" href="classbv_1_1bit__vector.html" title="Container class for dynamic b-tree bit vector stuctures.">bv::bit_vector</a> and <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a>, to support the dynamic b-tree bit vector structure.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Practical limitations</h3>
<p>The maximum logical size of the bit vector is \(2^{b - 1} - 1\) where b is the number of bits available in dtype. This is due to the "sign bit" being used to speed up branching. So for 64-bit words the maximum data structure size is 9223372036854775807 and for 32-bot words the limit is 2147483647.</p>
<p>The internal nodes need to keep track of leaf sizes, since splitting, merging and balancing is done based on a top-down approach, where an insertion or removal already submitted to a leaf <b>cannot</b> cause any rebalancing.</p>
<p>The maximum leaf size practically needs to be divisible by 128 due to the practical allocation scheme allocating an even amount of 64-bit integers for leaf storage. In addition a minimum size of 128 causes edge cases in balancing that can result in undefined behaviour. Thus a minimum leaf size of 256 and divisibility of maximum leaf size by 128 is enforced by static assertions.</p>
<p>Buffered <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a> instances can not be bigger than \(2^{24} - 1\).</p>
<p>The branching factor for the internal nodes need to be 8, 16, 32, 64 or 128 due to how the branchless binary search is written. Further limited by the 7 bits available in the child counter.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Cache line size</h3>
<p>Branch selection uses binary search, which significantly benefits from agressive cache prefetching. It is suggested that a definition of <code>CACHLE_LINE</code> is given with the value of the cache line size for the (running) architecture. Make attempts to retrieve this information and passing the correct value to the compiler with the <code>-DCACHE_LINE</code> flag.</p>
<p>If the prefetching fails significantly due to prefetching being unavailable or the wrong cache line size, the current binary search based branch selection will likely be noticeably slower than a naive linear search.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">leaf_type</td><td>Type of leaf to use in the tree structure (E.g. <a class="el" href="classbv_1_1leaf.html" title="Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.">bv::leaf</a>). </td></tr>
    <tr><td class="paramname">dtype</td><td>Integer type to use for indexing (uint32_t or uint64_t). </td></tr>
    <tr><td class="paramname">leaf_size</td><td>Maximum size of a leaf node. </td></tr>
    <tr><td class="paramname">branches</td><td>Maximum branching factor of internal nodes. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3064a3b2686b8e4f4264d0fdcb510aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064a3b2686b8e4f4264d0fdcb510aed">&#9670;&nbsp;</a></span>append_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::append_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all children from "other" to the end of this node. </p>
<p>Internal cumulative sizes and sums will be updated for this node but not for other. This is used when merging 2 nodes, where the "right" sibling will be deallocated after copying.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Node to copy elements from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a667820844114f3bb0004272dcc8c077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667820844114f3bb0004272dcc8c077b">&#9670;&nbsp;</a></span>append_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class child &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::append_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html#a95404ba2d241e1621c305ec511026fce">child</a> *&#160;</td>
          <td class="paramname"><em>new_child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add child to the subtree. </p>
<p>Mainly intended for use by <a class="el" href="classbv_1_1bit__vector.html" title="Container class for dynamic b-tree bit vector stuctures.">bv::bit_vector</a> for splitting root nodes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">child</td><td>Type of child (node or leaf_type).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_child</td><td>Child to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac704bf7b4d5ddfc2f150f9d73ee68bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac704bf7b4d5ddfc2f150f9d73ee68bea">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::at </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value of the index<sup>th</sup> element of the logical structure. </p>
<p>Recurses to children based on cumulative sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to access. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8058dc416614319ee5c00c473dc8146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8058dc416614319ee5c00c473dc8146">&#9670;&nbsp;</a></span>bits_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::bits_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the subtree in "allocated" bits. </p>
<p>Reports number of bits allocated for this subtree, Does not take into account any sort of memory fragmentation or similar.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of allocated bits. </dd></dl>

</div>
</div>
<a id="a95404ba2d241e1621c305ec511026fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95404ba2d241e1621c305ec511026fce">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::child </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get i<sup>th</sup> child of the node. </p>
<p>Mainly intended for use by <a class="el" href="classbv_1_1bit__vector.html" title="Container class for dynamic b-tree bit vector stuctures.">bv::bit_vector</a> for decreasing tree height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of child to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the i<sup>th</sup> child. </dd></dl>

</div>
</div>
<a id="ac847a9047faf8dfbd52b3a2b91197cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847a9047faf8dfbd52b3a2b91197cf0">&#9670;&nbsp;</a></span>child_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::child_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of children of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of children. </dd></dl>

</div>
</div>
<a id="aa7107ee49f44c1fc4af123ac20855434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7107ee49f44c1fc4af123ac20855434">&#9670;&nbsp;</a></span>child_sizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1branchless__scan.html">branching</a>* <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::child_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the cumulative child sizes. </p>
<p>Intended for efficient acces when balancing nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Address of the array of cumulative child sizes. </dd></dl>

</div>
</div>
<a id="af01debf052fe9f5831aa56c40de9cbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01debf052fe9f5831aa56c40de9cbe4">&#9670;&nbsp;</a></span>child_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1branchless__scan.html">branching</a>* <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::child_sums </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the cumulative child sums. </p>
<p>Intended for efficient acces when balancing nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Address of the array of cumulative child sums. </dd></dl>

</div>
</div>
<a id="aca9966c28ef766b094cc83b2c8fb463f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9966c28ef766b094cc83b2c8fb463f">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void** <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the children of this node. </p>
<p>Intended for efficient acces when balancing nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Address to the array of children of this node. </dd></dl>

</div>
</div>
<a id="aa1213cc63e7b62e7923ae94fca02787c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1213cc63e7b62e7923ae94fca02787c">&#9670;&nbsp;</a></span>clear_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::clear_first </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>elems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the first "elems" elements form this node. </p>
<p>Internal cumulative sizes and sums will be updated, but removed nodes will not be deallocated, as it is assumed that this is triggered after copying elements to the "left" sibling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td>Number of elements to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf0a2977c1024b410e84b9e4be7397d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0a2977c1024b410e84b9e4be7397d6">&#9670;&nbsp;</a></span>clear_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::clear_last </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>elems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last "elems" elemets from the node. </p>
<p>Internal cumulative sizes and sums will be updated, but removed nodes will not be deallocated, as it is assumed that this is triggered after copying elements to the "right" sibling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td>Number of elements to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae139057da6d7a5e248b321f3914468e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae139057da6d7a5e248b321f3914468e6">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively deallocates all children. </p>
<p>A separate allocator is needed in addition to <code>~node()</code> since binding deallocation of children to the default destructor could lead to deallocation of nodes that are still in use with other nodes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for deallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d8ab5b2b761ac226f455dfad665162e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8ab5b2b761ac226f455dfad665162e">&#9670;&nbsp;</a></span>has_leaves() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::has_leaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of children for the node. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the children of this node are leaves. </dd></dl>

</div>
</div>
<a id="ab25112ec2200c74cb83b6feab93ef9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25112ec2200c74cb83b6feab93ef9a1">&#9670;&nbsp;</a></span>has_leaves() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::has_leaves </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether the children of the node are leaves or internal nodes. </p>
<p>Intended to be set according to the status of siblings following allocation of the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>Boolean value indicating if the children of this node are leaves. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf15e749a6311c34ae62eaa4ad9ddfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf15e749a6311c34ae62eaa4ad9ddfd9">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert "value" at "index". </p>
<p>Inserts into the logical bit vector whlie ensuring that structural invariants hold. Children will be rebalanced or split as necessary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Location for insertion. </td></tr>
    <tr><td class="paramname">value</td><td>Boolean indicating the value for the new element. </td></tr>
    <tr><td class="paramname">alloc</td><td>Instance of allocator to use for allocation and reallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad56b0771306c929622f11ecb2903df1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56b0771306c929622f11ecb2903df1d">&#9670;&nbsp;</a></span>leaf_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::leaf_insert </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion operation if the children are leaves. </p>
<p>Reallocation and rebalancing will take place as necessary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Location of insertion. </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
    <tr><td class="paramname">alloc</td><td>Instance of alloctor to use for allocation and reallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a679beca7562433e0505191474c63d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679beca7562433e0505191474c63d518">&#9670;&nbsp;</a></span>leaf_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::leaf_remove </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removal used when the children are leaves. </p>
<p>Will maintain structural invarians by, reallocating and rebalancing as necessary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of element to remove. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for reallocation and deallocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of removed element. </dd></dl>

</div>
</div>
<a id="a458944e99726b8562eccbe8f668b9414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458944e99726b8562eccbe8f668b9414">&#9670;&nbsp;</a></span>merge_leaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::merge_leaves </td>
          <td>(</td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the right leaf into the left leaf. </p>
<p>Intended for when a removal would break structural invariant and there are not enough elements in siblings to transfer elements wilhe maintaining invariants.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>"Left" leaf. </td></tr>
    <tr><td class="paramname">b</td><td>"Right" leaf. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of left leaf for reallocation. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for reallocation and deallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a848207658f45cb304b07b3478f7fefe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848207658f45cb304b07b3478f7fefe5">&#9670;&nbsp;</a></span>merge_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::merge_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer all from the "right" node to the "left" node. </p>
<p>Intended for rebalancing when a removal may break structural invariants but rebalancing is impractical due to fill rate of siblings being \(\approx \frac{1}{3}\). Nodes will be merged instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>"Left" leaf. </td></tr>
    <tr><td class="paramname">b</td><td>"Right" leaf. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the "left" node for updating cumulative sums and sizes. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for deallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6918444b124f2f4fd2c9eef9a43117bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6918444b124f2f4fd2c9eef9a43117bb">&#9670;&nbsp;</a></span>node_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::node_insert </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion operation if the children are internal nodes. </p>
<p>Reallocation and rebalancing will take place as necessary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Location of insertion. </td></tr>
    <tr><td class="paramname">value</td><td>Value to insert. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for allocation and reallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1df5aca9c6ae88fff2a762f10964259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df5aca9c6ae88fff2a762f10964259f">&#9670;&nbsp;</a></span>node_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::node_remove </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removal operation when children are internal nodes. </p>
<p>Recursively call the removal to children that are internal nodes. Maintains structural invariants by rebalancing and merging nodes as necessary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of element to be removed. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instanve for eallocation and deallocatioin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of removed element. </dd></dl>

</div>
</div>
<a id="a3bf18e7fb6cd2f123b4ac9726dacdbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf18e7fb6cd2f123b4ac9726dacdbee">&#9670;&nbsp;</a></span>p_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dtype <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::p_sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical number of 1-bits stored in the subtree. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of 1-bits in subtree. </dd></dl>

</div>
</div>
<a id="a102f163e9ac6b0842c11ce624aa19642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102f163e9ac6b0842c11ce624aa19642">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internal_only</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs this subtree as json. </p>
<p>Prints this and all subtrees recursively. A final new line will not be output, since it is assumed that this is called from another internal node or a root element like <a class="el" href="classbv_1_1bit__vector.html" title="Container class for dynamic b-tree bit vector stuctures.">bv::bit_vector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal_only</td><td>If true, leaves will not output their data arrays to save space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe9c306d0befba0e1fca4d6178aaf6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9c306d0befba0e1fca4d6178aaf6f0">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dtype <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rank </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts number of one bits up to the index<sup>th</sup> logical element. </p>
<p>Recurses to children based on cumulative sizes and returns subtree rank based on the result of the recurrence and local cumulative sums.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Number of elements to sum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\sum_{i = 0}^{\mathrm{index - 1}} \mathrm{bv}[i]\). </dd></dl>

</div>
</div>
<a id="abfa478cf40b029e8e89c99ad4fd62b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa478cf40b029e8e89c99ad4fd62b19">&#9670;&nbsp;</a></span>rebalance_leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rebalance_leaf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that there is space for insertion in the child leaves. </p>
<p>If there is sufficient space in either sibling, elements will be transferred to the sibling with more room. If there is insufficient space in the siblings, a new leaf is allocated and elements are transferred from the target leaf to one of the siblings.</p>
<p>Generally delays allocation of a new leaf as long as posisble, and when reallocating, generates a new leaf that is \(\approx \frac{2}{3}\) full.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Location of the full leaf. </td></tr>
    <tr><td class="paramname">leaf</td><td>Pointer to the full leaf. </td></tr>
    <tr><td class="paramname">alloc</td><td>Instance of allocator to use for reallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2179a509cec5f2cca091d6035472fdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2179a509cec5f2cca091d6035472fdf5">&#9670;&nbsp;</a></span>rebalance_leaves_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rebalance_leaves_left </td>
          <td>(</td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from the "left" leaf to the "right" leaf. </p>
<p>Intended for rebalancing when a removal targets the "right" leaf but there are too few elements in the leaf to maintain structural invariants.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>"Left" leaf. </td></tr>
    <tr><td class="paramname">b</td><td>"Right" leaf. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the "left" leaf for use when reallocating. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for allocation and reallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afba13b4bd1acc8adf5c69e17cd3e0844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba13b4bd1acc8adf5c69e17cd3e0844">&#9670;&nbsp;</a></span>rebalance_leaves_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rebalance_leaves_right </td>
          <td>(</td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">leaf_type *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from the "right" leaf to the "left" leaf. </p>
<p>Intended for rebalancing when a removal targets the "left" leaf but there are too few elements in the leaf to maintain structural invariants.</p>
<p>Only called when the "left" leaf has index 0. Thus no need for the target indexes for reallocation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>"Left" leaf. </td></tr>
    <tr><td class="paramname">b</td><td>"Right" leaf. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for allocation and reallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7404ff49559a0e9d194d8fd74e1b58ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7404ff49559a0e9d194d8fd74e1b58ab">&#9670;&nbsp;</a></span>rebalance_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rebalance_node </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that there is space for insertion in the child nodes. </p>
<p>If there is sufficient space in either sibling, elements will be transferred to the sibling with more room. If there is insufficient space in the siblings, a new node is allocated and elements are transferred from the target node to one of the siblings.</p>
<p>Generally delays allocation of a new node as long as possible, and when reallocating, generates a new node that is \(\approx \frac{2}{3}\) full.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Location of the full node. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance to use for allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3df575c9efb74baa579888b780327472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df575c9efb74baa579888b780327472">&#9670;&nbsp;</a></span>rebalance_nodes_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rebalance_nodes_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from the "lef" node to the "right" node. </p>
<p>Intended for rebalancing when a removal targets the "right" node but there are too few elements in the node to ensure that structural invariants are maintained.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>allocator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>"Left" leaf. </td></tr>
    <tr><td class="paramname">b</td><td>"Right" leaf. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the Left node for use when updating cumulative sizes and sums. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3bb4e623e06394829bb794586176191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bb4e623e06394829bb794586176191">&#9670;&nbsp;</a></span>rebalance_nodes_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::rebalance_nodes_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from the "right" node to the "left" node. </p>
<p>Intended for rebalancing when a removal targets the "left" node but there are too few elements in the node to ensure that structural invariants are maintained.</p>
<p>Only called when the "left" node has index 0. Thus no need for the target indexes for reallocation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>allocator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>"Left" node. </td></tr>
    <tr><td class="paramname">b</td><td>"Right" node. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of "left" node for updating cumulative sizes and sums. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada1ee834ac68d417cfcdfd18b098b98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1ee834ac68d417cfcdfd18b098b98b">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<div class="memtemplate">
template&lt;class allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">allocator *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the index<sup>th</sup> element. </p>
<p>Removes element at "index" while ensuring that strctural invariants hold. Children will be rebalanced and merger as necessary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">allocator</td><td>Type of <code>alloc</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Location for removal. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for reallocation and deallocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab48b17e82e1a4a81aa80d6fd38991383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48b17e82e1a4a81aa80d6fd38991383">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dtype <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::select </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the index of the count<sup>tu</sup> 1-bit. </p>
<p>Recurses to children based on cumulative sums and returns subtree Select based on the results of the recurrence and local cumulative sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number to sum up to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\underset{i \in [0..n)}{\mathrm{arg min}}\left(\sum_{j = 0}^i \mathrm{bv}[j]\right) = \) count. </dd></dl>

</div>
</div>
<a id="a2bf12280dae2634721d0d8d8206fee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf12280dae2634721d0d8d8206fee63">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::set </td>
          <td>(</td>
          <td class="paramtype">dtype&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the logical index<sup>th</sup> element to v. </p>
<p>Recurses to children based on cumulative sizes and updates partial sums based on return value. Change is returned so parents can update partial sums as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of element to set value of </td></tr>
    <tr><td class="paramname">v</td><td>Value to set element to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Change to data structure sum triggered by the set operation. </dd></dl>

</div>
</div>
<a id="acbdfb951964fa5b8583178a79671e392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdfb951964fa5b8583178a79671e392">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dtype <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logical number of elements stored in the subtree. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in subtree. </dd></dl>

</div>
</div>
<a id="a5e149d613997ccfeb052ad7d181f7fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e149d613997ccfeb052ad7d181f7fcc">&#9670;&nbsp;</a></span>transfer_append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::transfer_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the fist "elems" elements from "other" to the end of "this". </p>
<p>Elements are first copied to this node, after which <code>clear_firs(elems)</code> will be called on "other". Cumulative sizes and sums will be updated accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Node to transfer elements from. </td></tr>
    <tr><td class="paramname">elems</td><td>Number of elements to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd5c13dba4cac468ffc2513f55335dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5c13dba4cac468ffc2513f55335dae">&#9670;&nbsp;</a></span>transfer_prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::transfer_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1node.html">node</a>&lt; leaf_type, dtype, leaf_size, branches &gt; *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the last "elems" elements from "other" to the start of "this". </p>
<p>Elements are first copied to this node, after which <code>clear_firs(elems)</code> will be called on "other". Cumulative sizes and sums will be updated accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Node to transfer elements from. </td></tr>
    <tr><td class="paramname">elems</td><td>Number of elements to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f9dc1092d0dbac400e2eaa0787ae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f9dc1092d0dbac400e2eaa0787ae17">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class leaf_type , class dtype , uint64_t leaf_size, uint8_t branches&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1node.html">bv::node</a>&lt; leaf_type, dtype, leaf_size, branches &gt;::validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the subtree structure is internally consistent. </p>
<p>Checks that cumulative sizes and sums agree with the reported sizes and sums of the children.</p>
<p>If the children are leaves, also checks the validity of capacity for the child.</p>
<p>If compiled with <code>NDEBUG</code> defined, this function will do essentially nothing since all checks are based on C assertions.</p>
<p>Also does not say anything about the correctness of the subtree given the sequence of operations up to this point. Only guarantees that the structure is internally consistent and "could" be the result of some valid sequence of operations.</p>
<p>Number of nodes are reported for verification of allocation counts.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of nodes in this subtree. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bit_vector/internal/<a class="el" href="node_8hpp_source.html">node.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 26 2021 14:20:52 for Bit vector by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
