<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bit vector: bv::leaf&lt; buffer_size, avx &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bit vector
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Fast and space efficient dynamic bit vector library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bv</b></li><li class="navelem"><a class="el" href="classbv_1_1leaf.html">leaf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classbv_1_1leaf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bv::leaf&lt; buffer_size, avx &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector.  
 <a href="classbv_1_1leaf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="leaf_8hpp_source.html">leaf.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3d053d183a6cc9b268675dab349ed291"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a3d053d183a6cc9b268675dab349ed291">leaf</a> (uint64_t <a class="el" href="classbv_1_1leaf.html#ad9eafe86e48fe7ba0f0381520ac30531">capacity</a>, uint64_t *<a class="el" href="classbv_1_1leaf.html#ae74d60f6c55e096e8632bef23471620d">data</a>)</td></tr>
<tr class="memdesc:a3d053d183a6cc9b268675dab349ed291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaf constructor.  <a href="classbv_1_1leaf.html#a3d053d183a6cc9b268675dab349ed291">More...</a><br /></td></tr>
<tr class="separator:a3d053d183a6cc9b268675dab349ed291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af308d5eeb5d80e924ed180db52bb0ee2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#af308d5eeb5d80e924ed180db52bb0ee2">at</a> (const uint32_t i) const</td></tr>
<tr class="memdesc:af308d5eeb5d80e924ed180db52bb0ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the i<sup>th</sup> element in the leaf.  <a href="classbv_1_1leaf.html#af308d5eeb5d80e924ed180db52bb0ee2">More...</a><br /></td></tr>
<tr class="separator:af308d5eeb5d80e924ed180db52bb0ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b695c79739b5c77d8fe808f85dd848a"><td class="memItemLeft" align="right" valign="top"><a id="a5b695c79739b5c77d8fe808f85dd848a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a5b695c79739b5c77d8fe808f85dd848a">p_sum</a> () const</td></tr>
<tr class="memdesc:a5b695c79739b5c77d8fe808f85dd848a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for p_sum_. <br /></td></tr>
<tr class="separator:a5b695c79739b5c77d8fe808f85dd848a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74c1e34145f7acd5c61ccdec116e49f"><td class="memItemLeft" align="right" valign="top"><a id="aa74c1e34145f7acd5c61ccdec116e49f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#aa74c1e34145f7acd5c61ccdec116e49f">size</a> () const</td></tr>
<tr class="memdesc:aa74c1e34145f7acd5c61ccdec116e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for size_. <br /></td></tr>
<tr class="separator:aa74c1e34145f7acd5c61ccdec116e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381923edd5cf825653e30b47455d995d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a381923edd5cf825653e30b47455d995d">insert</a> (const uint64_t i, const bool x)</td></tr>
<tr class="memdesc:a381923edd5cf825653e30b47455d995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert x into position i.  <a href="classbv_1_1leaf.html#a381923edd5cf825653e30b47455d995d">More...</a><br /></td></tr>
<tr class="separator:a381923edd5cf825653e30b47455d995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cac3c8e3fd04423245e6619d9c5fcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a70cac3c8e3fd04423245e6619d9c5fcc">remove</a> (const uint64_t i)</td></tr>
<tr class="memdesc:a70cac3c8e3fd04423245e6619d9c5fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the i<sup>th</sup> bit from the leaf.  <a href="classbv_1_1leaf.html#a70cac3c8e3fd04423245e6619d9c5fcc">More...</a><br /></td></tr>
<tr class="separator:a70cac3c8e3fd04423245e6619d9c5fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d80e6c67137a30ab9c31d5b3021101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a19d80e6c67137a30ab9c31d5b3021101">set</a> (const uint64_t i, const bool x)</td></tr>
<tr class="memdesc:a19d80e6c67137a30ab9c31d5b3021101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the i<sup>th</sup> bit to x.  <a href="classbv_1_1leaf.html#a19d80e6c67137a30ab9c31d5b3021101">More...</a><br /></td></tr>
<tr class="separator:a19d80e6c67137a30ab9c31d5b3021101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dfb0c74b9839b550055fd93dc8cf3e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#ae7dfb0c74b9839b550055fd93dc8cf3e">rank</a> (const uint64_t n) const</td></tr>
<tr class="memdesc:ae7dfb0c74b9839b550055fd93dc8cf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of 1-bits up to position n.  <a href="classbv_1_1leaf.html#ae7dfb0c74b9839b550055fd93dc8cf3e">More...</a><br /></td></tr>
<tr class="separator:ae7dfb0c74b9839b550055fd93dc8cf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb3daf7c3567c924426d74bc69e903"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a16bb3daf7c3567c924426d74bc69e903">rank</a> (const uint64_t n, const uint64_t offset) const</td></tr>
<tr class="memdesc:a16bb3daf7c3567c924426d74bc69e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of 1-bits up to position n from position offset.  <a href="classbv_1_1leaf.html#a16bb3daf7c3567c924426d74bc69e903">More...</a><br /></td></tr>
<tr class="separator:a16bb3daf7c3567c924426d74bc69e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae36d25acec747b82fb12da32c347661"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#aae36d25acec747b82fb12da32c347661">select</a> (const uint32_t x) const</td></tr>
<tr class="memdesc:aae36d25acec747b82fb12da32c347661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the x<sup>th</sup> 1-bit in the data structure.  <a href="classbv_1_1leaf.html#aae36d25acec747b82fb12da32c347661">More...</a><br /></td></tr>
<tr class="separator:aae36d25acec747b82fb12da32c347661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc299f0c4cb4a2115ae8ec0e7714f0fa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#adc299f0c4cb4a2115ae8ec0e7714f0fa">select</a> (const uint32_t x, uint32_t pos, uint32_t pop) const</td></tr>
<tr class="memdesc:adc299f0c4cb4a2115ae8ec0e7714f0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the x<sup>th</sup> 1-bit in the data structure starting at <code>pos</code> with <code>pop</code>  <a href="classbv_1_1leaf.html#adc299f0c4cb4a2115ae8ec0e7714f0fa">More...</a><br /></td></tr>
<tr class="separator:adc299f0c4cb4a2115ae8ec0e7714f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7104583e1fed9975f0313b771cf78d07"><td class="memItemLeft" align="right" valign="top"><a id="a7104583e1fed9975f0313b771cf78d07"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a7104583e1fed9975f0313b771cf78d07">bits_size</a> () const</td></tr>
<tr class="memdesc:a7104583e1fed9975f0313b771cf78d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the leaf and associated data in bits. <br /></td></tr>
<tr class="separator:a7104583e1fed9975f0313b771cf78d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b6cbe028c84fa34c1bbecec8adf56a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a72b6cbe028c84fa34c1bbecec8adf56a">need_realloc</a> () const</td></tr>
<tr class="memdesc:a72b6cbe028c84fa34c1bbecec8adf56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if reallocation / splitting is required prior to additional insertion of new elements.  <a href="classbv_1_1leaf.html#a72b6cbe028c84fa34c1bbecec8adf56a">More...</a><br /></td></tr>
<tr class="separator:a72b6cbe028c84fa34c1bbecec8adf56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eafe86e48fe7ba0f0381520ac30531"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#ad9eafe86e48fe7ba0f0381520ac30531">capacity</a> () const</td></tr>
<tr class="memdesc:ad9eafe86e48fe7ba0f0381520ac30531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the leaf-associated data storage in 64-bit words.  <a href="classbv_1_1leaf.html#ad9eafe86e48fe7ba0f0381520ac30531">More...</a><br /></td></tr>
<tr class="separator:ad9eafe86e48fe7ba0f0381520ac30531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebae604de04ce152280edb611bc83bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#aebae604de04ce152280edb611bc83bc2">capacity</a> (uint32_t cap)</td></tr>
<tr class="memdesc:aebae604de04ce152280edb611bc83bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the leaf-associated data storage.  <a href="classbv_1_1leaf.html#aebae604de04ce152280edb611bc83bc2">More...</a><br /></td></tr>
<tr class="separator:aebae604de04ce152280edb611bc83bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e3b8778a102033d5c9c3b419fa997d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#ab1e3b8778a102033d5c9c3b419fa997d">set_data_ptr</a> (uint64_t *ptr)</td></tr>
<tr class="memdesc:ab1e3b8778a102033d5c9c3b419fa997d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pointer to the leaf-associated data storage.  <a href="classbv_1_1leaf.html#ab1e3b8778a102033d5c9c3b419fa997d">More...</a><br /></td></tr>
<tr class="separator:ab1e3b8778a102033d5c9c3b419fa997d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74d60f6c55e096e8632bef23471620d"><td class="memItemLeft" align="right" valign="top">uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#ae74d60f6c55e096e8632bef23471620d">data</a> ()</td></tr>
<tr class="memdesc:ae74d60f6c55e096e8632bef23471620d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to raw leaf-associated data.  <a href="classbv_1_1leaf.html#ae74d60f6c55e096e8632bef23471620d">More...</a><br /></td></tr>
<tr class="separator:ae74d60f6c55e096e8632bef23471620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce4dfe392785421e602354485df46a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a1ce4dfe392785421e602354485df46a4">clear_first</a> (uint64_t elems)</td></tr>
<tr class="memdesc:a1ce4dfe392785421e602354485df46a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the fist "elems" elements from the leaf.  <a href="classbv_1_1leaf.html#a1ce4dfe392785421e602354485df46a4">More...</a><br /></td></tr>
<tr class="separator:a1ce4dfe392785421e602354485df46a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaa678c11098f7b1df0ce42132a4cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#affaa678c11098f7b1df0ce42132a4cc8">transfer_append</a> (<a class="el" href="classbv_1_1leaf.html">leaf</a> *other, uint64_t elems)</td></tr>
<tr class="memdesc:affaa678c11098f7b1df0ce42132a4cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move "elems" elements from the start of "other" to the end of "this".  <a href="classbv_1_1leaf.html#affaa678c11098f7b1df0ce42132a4cc8">More...</a><br /></td></tr>
<tr class="separator:affaa678c11098f7b1df0ce42132a4cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae902140cfd3665c9acd85039a25af8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#aae902140cfd3665c9acd85039a25af8e">clear_last</a> (uint64_t elems)</td></tr>
<tr class="memdesc:aae902140cfd3665c9acd85039a25af8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last "elems" elements from the leaf.  <a href="classbv_1_1leaf.html#aae902140cfd3665c9acd85039a25af8e">More...</a><br /></td></tr>
<tr class="separator:aae902140cfd3665c9acd85039a25af8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c926af47de5c7569844b76fe6e73433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a5c926af47de5c7569844b76fe6e73433">transfer_prepend</a> (<a class="el" href="classbv_1_1leaf.html">leaf</a> *other, uint64_t elems)</td></tr>
<tr class="memdesc:a5c926af47de5c7569844b76fe6e73433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move "elems" elements from the end of "other" to the start of "this".  <a href="classbv_1_1leaf.html#a5c926af47de5c7569844b76fe6e73433">More...</a><br /></td></tr>
<tr class="separator:a5c926af47de5c7569844b76fe6e73433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe59292eb12f672767516224cdee5752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#abe59292eb12f672767516224cdee5752">append_all</a> (<a class="el" href="classbv_1_1leaf.html">leaf</a> *other)</td></tr>
<tr class="memdesc:abe59292eb12f672767516224cdee5752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all elements from (the start of) "other" to the end of "this".  <a href="classbv_1_1leaf.html#abe59292eb12f672767516224cdee5752">More...</a><br /></td></tr>
<tr class="separator:abe59292eb12f672767516224cdee5752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce27752df1df5ebe6b1fd6c17e79c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#acce27752df1df5ebe6b1fd6c17e79c55">commit</a> ()</td></tr>
<tr class="memdesc:acce27752df1df5ebe6b1fd6c17e79c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit and clear the Insert/Remove buffer for the leaf.  <a href="classbv_1_1leaf.html#acce27752df1df5ebe6b1fd6c17e79c55">More...</a><br /></td></tr>
<tr class="separator:acce27752df1df5ebe6b1fd6c17e79c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a8696df9bdda57a46e824c79e24dcc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#aa8a8696df9bdda57a46e824c79e24dcc">validate</a> () const</td></tr>
<tr class="memdesc:aa8a8696df9bdda57a46e824c79e24dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the leaf is in a valid state.  <a href="classbv_1_1leaf.html#aa8a8696df9bdda57a46e824c79e24dcc">More...</a><br /></td></tr>
<tr class="separator:aa8a8696df9bdda57a46e824c79e24dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1766922dc590897519b4fb1c851430"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a1f1766922dc590897519b4fb1c851430">print</a> (bool internal_only) const</td></tr>
<tr class="memdesc:a1f1766922dc590897519b4fb1c851430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output data stored in the leaf as json.  <a href="classbv_1_1leaf.html#a1f1766922dc590897519b4fb1c851430">More...</a><br /></td></tr>
<tr class="separator:a1f1766922dc590897519b4fb1c851430"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a347d4d845f2b3a922c9787d2b120506a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a347d4d845f2b3a922c9787d2b120506a">buffer_value</a> (uint32_t e) const</td></tr>
<tr class="memdesc:a347d4d845f2b3a922c9787d2b120506a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value of a buffer element.  <a href="classbv_1_1leaf.html#a347d4d845f2b3a922c9787d2b120506a">More...</a><br /></td></tr>
<tr class="separator:a347d4d845f2b3a922c9787d2b120506a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97782dcb0cbb0a75943a5358ff74b40c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a97782dcb0cbb0a75943a5358ff74b40c">buffer_is_insertion</a> (uint32_t e) const</td></tr>
<tr class="memdesc:a97782dcb0cbb0a75943a5358ff74b40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract type information of a buffer element.  <a href="classbv_1_1leaf.html#a97782dcb0cbb0a75943a5358ff74b40c">More...</a><br /></td></tr>
<tr class="separator:a97782dcb0cbb0a75943a5358ff74b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bda2ec1e0cfca8a4ed8e5c22754a3e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a20bda2ec1e0cfca8a4ed8e5c22754a3e">buffer_index</a> (uint32_t e) const</td></tr>
<tr class="memdesc:a20bda2ec1e0cfca8a4ed8e5c22754a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract index information from a butter element.  <a href="classbv_1_1leaf.html#a20bda2ec1e0cfca8a4ed8e5c22754a3e">More...</a><br /></td></tr>
<tr class="separator:a20bda2ec1e0cfca8a4ed8e5c22754a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc207b79bac43eb153e4242257dc475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a7fc207b79bac43eb153e4242257dc475">set_buffer_index</a> (uint32_t v, uint8_t i)</td></tr>
<tr class="memdesc:a7fc207b79bac43eb153e4242257dc475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates index information for a specified buffer element.  <a href="classbv_1_1leaf.html#a7fc207b79bac43eb153e4242257dc475">More...</a><br /></td></tr>
<tr class="separator:a7fc207b79bac43eb153e4242257dc475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375b037ab1fa48cd7916989fb57da1ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a375b037ab1fa48cd7916989fb57da1ff">create_buffer</a> (uint32_t idx, bool t, bool v)</td></tr>
<tr class="memdesc:a375b037ab1fa48cd7916989fb57da1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new 32-bit buffer element with the given parameters.  <a href="classbv_1_1leaf.html#a375b037ab1fa48cd7916989fb57da1ff">More...</a><br /></td></tr>
<tr class="separator:a375b037ab1fa48cd7916989fb57da1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1d38ed8c9721890c57a211c9d3f860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a6c1d38ed8c9721890c57a211c9d3f860">insert_buffer</a> (uint8_t idx, uint32_t buf)</td></tr>
<tr class="memdesc:a6c1d38ed8c9721890c57a211c9d3f860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element into the buffer.  <a href="classbv_1_1leaf.html#a6c1d38ed8c9721890c57a211c9d3f860">More...</a><br /></td></tr>
<tr class="separator:a6c1d38ed8c9721890c57a211c9d3f860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d257292df493f4f38aa78e037a8af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#af12d257292df493f4f38aa78e037a8af">delete_buffer_element</a> (uint8_t idx)</td></tr>
<tr class="memdesc:af12d257292df493f4f38aa78e037a8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the buffer.  <a href="classbv_1_1leaf.html#af12d257292df493f4f38aa78e037a8af">More...</a><br /></td></tr>
<tr class="separator:af12d257292df493f4f38aa78e037a8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3203c6025d5272ea52a560720ee23a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a3a3203c6025d5272ea52a560720ee23a">push_back</a> (const bool x)</td></tr>
<tr class="memdesc:a3a3203c6025d5272ea52a560720ee23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the end of the leaf data.  <a href="classbv_1_1leaf.html#a3a3203c6025d5272ea52a560720ee23a">More...</a><br /></td></tr>
<tr class="separator:a3a3203c6025d5272ea52a560720ee23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abf9a66b34ff5479b3fb7f4cc98d40386"><td class="memItemLeft" align="right" valign="top"><a id="abf9a66b34ff5479b3fb7f4cc98d40386"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#abf9a66b34ff5479b3fb7f4cc98d40386">buffer_count_</a></td></tr>
<tr class="memdesc:abf9a66b34ff5479b3fb7f4cc98d40386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in insert/remove buffer. <br /></td></tr>
<tr class="separator:abf9a66b34ff5479b3fb7f4cc98d40386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7c9d64aaebed4278aeda426910fa22"><td class="memItemLeft" align="right" valign="top"><a id="aeb7c9d64aaebed4278aeda426910fa22"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#aeb7c9d64aaebed4278aeda426910fa22">capacity_</a></td></tr>
<tr class="memdesc:aeb7c9d64aaebed4278aeda426910fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of 64-bit integers available in data. <br /></td></tr>
<tr class="separator:aeb7c9d64aaebed4278aeda426910fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1fc0fd0857a6060a871d6d2f1e167"><td class="memItemLeft" align="right" valign="top"><a id="a79a1fc0fd0857a6060a871d6d2f1e167"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a79a1fc0fd0857a6060a871d6d2f1e167">size_</a></td></tr>
<tr class="memdesc:a79a1fc0fd0857a6060a871d6d2f1e167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical number of bits stored. <br /></td></tr>
<tr class="separator:a79a1fc0fd0857a6060a871d6d2f1e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be1cf26ce90465197624b710ebe13a"><td class="memItemLeft" align="right" valign="top"><a id="a70be1cf26ce90465197624b710ebe13a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a70be1cf26ce90465197624b710ebe13a">p_sum_</a></td></tr>
<tr class="memdesc:a70be1cf26ce90465197624b710ebe13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical number of 1-bits stored. <br /></td></tr>
<tr class="separator:a70be1cf26ce90465197624b710ebe13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e677d3bcb1435ea0b9a8c4fe6daa793"><td class="memItemLeft" align="right" valign="top"><a id="a0e677d3bcb1435ea0b9a8c4fe6daa793"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a0e677d3bcb1435ea0b9a8c4fe6daa793">buffer_</a> [buffer_size]</td></tr>
<tr class="memdesc:a0e677d3bcb1435ea0b9a8c4fe6daa793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert/remove buffer. <br /></td></tr>
<tr class="separator:a0e677d3bcb1435ea0b9a8c4fe6daa793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5538dd6fe3f924c98ccbed4965dae198"><td class="memItemLeft" align="right" valign="top"><a id="a5538dd6fe3f924c98ccbed4965dae198"></a>
uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a5538dd6fe3f924c98ccbed4965dae198">data_</a></td></tr>
<tr class="memdesc:a5538dd6fe3f924c98ccbed4965dae198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to data storage. <br /></td></tr>
<tr class="separator:a5538dd6fe3f924c98ccbed4965dae198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a3962e2bf7e50e9ce67414167528a0c76"><td class="memItemLeft" align="right" valign="top"><a id="a3962e2bf7e50e9ce67414167528a0c76"></a>
static const constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a3962e2bf7e50e9ce67414167528a0c76">MASK</a> = 1</td></tr>
<tr class="memdesc:a3962e2bf7e50e9ce67414167528a0c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">0x1 to be used in bit operations. <br /></td></tr>
<tr class="separator:a3962e2bf7e50e9ce67414167528a0c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d3c62a8530665493c136bc07843786"><td class="memItemLeft" align="right" valign="top"><a id="a36d3c62a8530665493c136bc07843786"></a>
static const constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a36d3c62a8530665493c136bc07843786">VALUE_MASK</a> = 1</td></tr>
<tr class="memdesc:a36d3c62a8530665493c136bc07843786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for accessing buffer value. <br /></td></tr>
<tr class="separator:a36d3c62a8530665493c136bc07843786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657881af0792dc107ef309238355cda"><td class="memItemLeft" align="right" valign="top"><a id="a6657881af0792dc107ef309238355cda"></a>
static const constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a6657881af0792dc107ef309238355cda">TYPE_MASK</a> = 8</td></tr>
<tr class="memdesc:a6657881af0792dc107ef309238355cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for accessing buffer type. <br /></td></tr>
<tr class="separator:a6657881af0792dc107ef309238355cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdd146d046d36c83c77dec7a2ffca46"><td class="memItemLeft" align="right" valign="top"><a id="a2cdd146d046d36c83c77dec7a2ffca46"></a>
static const constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbv_1_1leaf.html#a2cdd146d046d36c83c77dec7a2ffca46">INDEX_MASK</a> = ((uint32_t(1) &lt;&lt; 8) - 1)</td></tr>
<tr class="memdesc:a2cdd146d046d36c83c77dec7a2ffca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for accessing buffer index value. <br /></td></tr>
<tr class="separator:a2cdd146d046d36c83c77dec7a2ffca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;uint8_t buffer_size, bool avx = true&gt;<br />
class bv::leaf&lt; buffer_size, avx &gt;</h3>

<p>Simple flat dynamic bit vector for use as a leaf for a dynamic b-tree bit vector. </p>
<p>The leaf is not usable as fully featured bit vector by itself since the leaf cannot reallocate itself when full. The leaf requires a parent structure (like <a class="el" href="classbv_1_1bit__vector.html" title="Container class for dynamic b-tree bit vector stuctures.">bv::bit_vector</a> or <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a>) to manage reallocations and rebalancing.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
Practical limitations</h3>
<p>The maximum leaf size for a buffered leaf without risking undefined behaviour is \(2^{24} - 1\) due to buffer elements storing reference indexes in 24-bits of 32-bit integers. The practical upper limit of leaf size due to performance concerns is no more than \(2^{20}\) and optimal leaf size is likely to be closer to the \(2^{12}\) to \(2^{15}\) range.</p>
<p>Maximum leaf size can't in effect be non-divisible by 64, since 64-bit integers are used for storage and a leaf "will use" all available words fully before indicating that a reallocation is necessary, triggering limit checks.</p>
<p>The maximum buffer size is 63 due to storing the information on buffer usage with 6 bits of an 8-bit word, with 2 bits reserved for other purposes. This could easily be "fixed", but testing indicates that bigger buffer sizes are unlikely to be of practical use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>of insertion/removal buffer. </td></tr>
    <tr><td class="paramname">Use</td><td>avx population counts for rank operations. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3d053d183a6cc9b268675dab349ed291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d053d183a6cc9b268675dab349ed291">&#9670;&nbsp;</a></span>leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::<a class="el" href="classbv_1_1leaf.html">leaf</a> </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaf constructor. </p>
<p>The intention of this constructor is to enable either allocation of a larger consecutive memory block where the leaf struct can be placed at the start followed by the "data" section, or the data section can be allocated separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Number of 64-bit integers available for use in data. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to a contiguous memory area available for storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abe59292eb12f672767516224cdee5752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe59292eb12f672767516224cdee5752">&#9670;&nbsp;</a></span>append_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::append_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1leaf.html">leaf</a>&lt; buffer_size, avx &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all elements from (the start of) "other" to the end of "this". </p>
<p>Intended for merging leaves.</p>
<p><b>Will not</b> ensure sufficient capacity for merge.</p>
<p>Will ensure that the buffers are empty for both leaves.</p>
<p>Will now clear elements from "other" as it is assumed that "other" will be deallocated .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Pointer to next leaf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af308d5eeb5d80e924ed180db52bb0ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af308d5eeb5d80e924ed180db52bb0ee2">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the i<sup>th</sup> element in the leaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of bit at index i. </dd></dl>

</div>
</div>
<a id="a20bda2ec1e0cfca8a4ed8e5c22754a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bda2ec1e0cfca8a4ed8e5c22754a3e">&#9670;&nbsp;</a></span>buffer_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::buffer_index </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract index information from a butter element. </p>
<p>The 24 most significant bits of the 32-bit buffer element contain index information on the insert/removal operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Buffer element to extract index from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index information related to the buffer element. </dd></dl>

</div>
</div>
<a id="a97782dcb0cbb0a75943a5358ff74b40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97782dcb0cbb0a75943a5358ff74b40c">&#9670;&nbsp;</a></span>buffer_is_insertion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::buffer_is_insertion </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract type information of a buffer element. </p>
<p>The fourth least significant bit (<code>0b1000</code>), contains a 1 if the buffered operation is an insertion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Buffer element to extract type from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value True if the buffer is related to an insert operations, and false if the buffer is related to a removal. </dd></dl>

</div>
</div>
<a id="a347d4d845f2b3a922c9787d2b120506a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347d4d845f2b3a922c9787d2b120506a">&#9670;&nbsp;</a></span>buffer_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::buffer_value </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the value of a buffer element. </p>
<p>The First bit (lsb) of a 23-bit buffer element contains the value of the element.</p>
<p>I.e. if <code>bv[i]</code> is <code>1</code>, then the buffer created for <code>remove(i)</code> will have a lsb with value 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Buffer element to extract value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value indicating the value of the element referred to by the buffer. </dd></dl>

</div>
</div>
<a id="ad9eafe86e48fe7ba0f0381520ac30531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eafe86e48fe7ba0f0381520ac30531">&#9670;&nbsp;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of the leaf-associated data storage in 64-bit words. </p>
<p>Primarily intended for debugging and validation.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of internal data storage in 64-bit words. </dd></dl>

</div>
</div>
<a id="aebae604de04ce152280edb611bc83bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebae604de04ce152280edb611bc83bc2">&#9670;&nbsp;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the leaf-associated data storage. </p>
<p>Intended only to be set by an allocator after allocating additional storage for the leaf. Setting the capacity carelessly easily leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>New size for <code>data_</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce4dfe392785421e602354485df46a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce4dfe392785421e602354485df46a4">&#9670;&nbsp;</a></span>clear_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::clear_first </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the fist "elems" elements from the leaf. </p>
<p>Intended for removing elements that have been copied to a neighbouring leaf. Assumes that buffer has been committed before calling.</p>
<p>Will update size and p_sum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td>number of elements to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae902140cfd3665c9acd85039a25af8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae902140cfd3665c9acd85039a25af8e">&#9670;&nbsp;</a></span>clear_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::clear_last </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last "elems" elements from the leaf. </p>
<p>Intended for removing elements that have been copied to a neighbouring leaf. Assumes that buffer has been committed before calling.</p>
<p>Will update size and p_sum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td>number of elements to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acce27752df1df5ebe6b1fd6c17e79c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce27752df1df5ebe6b1fd6c17e79c55">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit and clear the Insert/Remove buffer for the leaf. </p>
<p>Intended for clearing a full buffer before insertion or removal, and for ensuring an empty buffer before transfer operations.</p>
<p>Slightly complicated but linear time function for committing all buffered operations to the underlying data. </p>

</div>
</div>
<a id="a375b037ab1fa48cd7916989fb57da1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375b037ab1fa48cd7916989fb57da1ff">&#9670;&nbsp;</a></span>create_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::create_buffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new 32-bit buffer element with the given parameters. </p>
<p>A new buffer element is typically created for insertion into the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index value for the new buffer element. </td></tr>
    <tr><td class="paramname">t</td><td>Type (Insert/Remove) of new buffer element. </td></tr>
    <tr><td class="paramname">v</td><td>Value associated with the new buffer element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae74d60f6c55e096e8632bef23471620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74d60f6c55e096e8632bef23471620d">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t* <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to raw leaf-associated data. </p>
<p>Intended for use when rebalancing and splitting leaves.</p>
<p>It is generally a very good idea to make sure the leaf buffer is committed before accessing the raw leaf data.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to raw leaf data. </dd></dl>

</div>
</div>
<a id="af12d257292df493f4f38aa78e037a8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12d257292df493f4f38aa78e037a8af">&#9670;&nbsp;</a></span>delete_buffer_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::delete_buffer_element </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an element from the buffer. </p>
<p>Existing elements with index greater than idx get shuffled backwards and the old element at idx will be overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Location of the element in the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a381923edd5cf825653e30b47455d995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381923edd5cf825653e30b47455d995d">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert x into position i. </p>
<p>The leaf <b>cannot reallocate</b> so inserting into a full leaf is undefined behaviour.</p>
<p>If the the buffer is not full or the insertion is appending a new element, the operation can be considered constant time. If the buffer is full and the insertion is not appending, the operations will be linear in the leaf size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Insertion index </td></tr>
    <tr><td class="paramname">x</td><td>Value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c1d38ed8c9721890c57a211c9d3f860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1d38ed8c9721890c57a211c9d3f860">&#9670;&nbsp;</a></span>insert_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::insert_buffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new element into the buffer. </p>
<p>Existing elements with index idx or greater gets shuffled forward and the new element will overwrite the buffer at index idx.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Position of the new element in the buffer. </td></tr>
    <tr><td class="paramname">buf</td><td>Element to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b6cbe028c84fa34c1bbecec8adf56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b6cbe028c84fa34c1bbecec8adf56a">&#9670;&nbsp;</a></span>need_realloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::need_realloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if reallocation / splitting is required prior to additional insertion of new elements. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there is no guarantee that an insertion can be completed without undefined behaviour. </dd></dl>

</div>
</div>
<a id="a1f1766922dc590897519b4fb1c851430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1766922dc590897519b4fb1c851430">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internal_only</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output data stored in the leaf as json. </p>
<p>Will output valid json, but will not output a trailing newline since the call is expected to be part of a recursive tree traversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">internal_only</td><td>Will not output raw data it true to save space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a3203c6025d5272ea52a560720ee23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3203c6025d5272ea52a560720ee23a">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an element to the end of the leaf data. </p>
<p>If naively writing to the next available position would cause an overflow, the buffer will be committed and this will guarantee that the next available position will become valid assuming proper handling of the leaf by the parent element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to be appended to the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7dfb0c74b9839b550055fd93dc8cf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dfb0c74b9839b550055fd93dc8cf3e">&#9670;&nbsp;</a></span>rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::rank </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of 1-bits up to position n. </p>
<p>Counts the number of bits set in the first n bits.</p>
<p>This is a simple linear operations of population counting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to include in the "summation".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\sum_{i = 0}^{\mathrm{index - 1}} \mathrm{bv}[i]\). </dd></dl>

</div>
</div>
<a id="a16bb3daf7c3567c924426d74bc69e903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bb3daf7c3567c924426d74bc69e903">&#9670;&nbsp;</a></span>rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::rank </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of 1-bits up to position n from position offset. </p>
<p>Counts the number of bits set in the [offset n) range.</p>
<p>This is a simple linear operations of population counting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>End position of summation. </td></tr>
    <tr><td class="paramname">offset</td><td>Start position of summation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\sum_{i = \mathrm{offset}}^{\mathrm{n- 1}} \mathrm{bv}[i]\). </dd></dl>

</div>
</div>
<a id="a70cac3c8e3fd04423245e6619d9c5fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cac3c8e3fd04423245e6619d9c5fcc">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the i<sup>th</sup> bit from the leaf. </p>
<p>No implicit balancing is possible in leaves without a managing parent (<a class="el" href="classbv_1_1bit__vector.html" title="Container class for dynamic b-tree bit vector stuctures.">bv::bit_vector</a> or <a class="el" href="classbv_1_1node.html" title="Internal node for use with bit vector b-tree structures.">bv::node</a>).</p>
<p>If the the buffer is not full the operation can be considered constant time. If the buffer is full, the operations will be linear in the leaf size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of removed element. </dd></dl>

</div>
</div>
<a id="aae36d25acec747b82fb12da32c347661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae36d25acec747b82fb12da32c347661">&#9670;&nbsp;</a></span>select() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the x<sup>th</sup> 1-bit in the data structure. </p>
<p>Select is a simple (if somewhat slow) linear time operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Selection target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\underset{i \in [0..n)}{\mathrm{arg min}}\left(\sum_{j = 0}^i \mathrm{bv}[j]\right) = x\). </dd></dl>

</div>
</div>
<a id="adc299f0c4cb4a2115ae8ec0e7714f0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc299f0c4cb4a2115ae8ec0e7714f0fa">&#9670;&nbsp;</a></span>select() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of the x<sup>th</sup> 1-bit in the data structure starting at <code>pos</code> with <code>pop</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Selection target. </td></tr>
    <tr><td class="paramname">pos</td><td>Start position of Select calculation. </td></tr>
    <tr><td class="paramname">pop</td><td>Start population as <code>pos</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\underset{i \in [0..n)}{\mathrm{arg min}}\left(\sum_{j = 0}^i \mathrm{bv}[j]\right) = x\). </dd></dl>

</div>
</div>
<a id="a19d80e6c67137a30ab9c31d5b3021101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d80e6c67137a30ab9c31d5b3021101">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the i<sup>th</sup> bit to x. </p>
<p>The value is changed in constant time (if buffer size is considered a constant). The change in data structure sum is returned for updateing cumulative sums in ancestor objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of bit to modify </td></tr>
    <tr><td class="paramname">x</td><td>New value for the i<sup>th</sup> element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(x - \mathrm{bv}[i]\) </dd></dl>

</div>
</div>
<a id="a7fc207b79bac43eb153e4242257dc475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc207b79bac43eb153e4242257dc475">&#9670;&nbsp;</a></span>set_buffer_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::set_buffer_index </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates index information for a specified buffer element. </p>
<p>Clears index information for the i<sup>th</sup> buffer element and replases it with v.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to set the buffer index to. </td></tr>
    <tr><td class="paramname">i</td><td>Index of buffer element in buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1e3b8778a102033d5c9c3b419fa997d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e3b8778a102033d5c9c3b419fa997d">&#9670;&nbsp;</a></span>set_data_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::set_data_ptr </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pointer to the leaf-associated data storage. </p>
<p>Intended only to be set by an allocator after allocating additional storage for the leaf. Setting the the pointer carelessly easily leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to data storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affaa678c11098f7b1df0ce42132a4cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaa678c11098f7b1df0ce42132a4cc8">&#9670;&nbsp;</a></span>transfer_append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::transfer_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1leaf.html">leaf</a>&lt; buffer_size, avx &gt; *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move "elems" elements from the start of "other" to the end of "this". </p>
<p><b>Will not</b> ensure sufficient capacity for the copy target.</p>
<p>The operation will ensure that the buffers of both leaves are cleared before transferring elements. Elements are first copied, after which, elements are cleared from the sibling with <code>other-&gt;clear_first(elems)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Pointer to the next sibling. </td></tr>
    <tr><td class="paramname">elems</td><td>Number of elements to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c926af47de5c7569844b76fe6e73433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c926af47de5c7569844b76fe6e73433">&#9670;&nbsp;</a></span>transfer_prepend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::transfer_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbv_1_1leaf.html">leaf</a>&lt; buffer_size, avx &gt; *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move "elems" elements from the end of "other" to the start of "this". </p>
<p><b>Will not</b> ensure sufficient capacity for the copy target.</p>
<p>The operation will ensure that the buffers of both leaves are cleared before transferring elements. Elements are first copied, after which, elements are cleared from the sibling with <code>other-&gt;clear_last(elems)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Pointer to the previous sibling. </td></tr>
    <tr><td class="paramname">elems</td><td>Number of elements to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a8696df9bdda57a46e824c79e24dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a8696df9bdda57a46e824c79e24dcc">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t buffer_size, bool avx = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="classbv_1_1leaf.html">bv::leaf</a>&lt; buffer_size, avx &gt;::validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that the leaf is in a valid state. </p>
<p>Will use assertions to check that the actual stored data agrees with stored metadata. Will not in any way that the leaf is in the correct state given the preceding sequence of operations, just that the leaf is in a state that is valid for a leaf.</p>
<p>If the compiler flag <code>-DNDEBUG</code> is given, this function will do nothing and may be completely optimized out by an optimizing compiler.</p>
<dl class="section return"><dt>Returns</dt><dd>1 for calculating the number of nodes in the tree. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bit_vector/internal/<a class="el" href="leaf_8hpp_source.html">leaf.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 26 2021 14:20:52 for Bit vector by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
